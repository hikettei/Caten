(in-package :caten/ajit)
;;
;; The list of nodes generated by render-graph.lisp is called a Render Graph.
;; transform.lisp applies a "graph-level optimization" to the given graph.
;; including:
;; - (Primitive) Loop Transformation. Loop Fusion and Loop Collapse
;; - Funcall -> Packed Funcall Transformation (see pack-loop-funcall), enabling the following stuff in the renderer level.
;;   - Loop Unroll
;;   - Vectorize
;;   - Tiling

(defstruct (Kernel-Renderer)
  (nodes (error "nodes must occur!") :type list)
  (nth 0 :type fixnum)
  (args nil))

(defmethod kernel-renderer-loop-depth ((k kernel-renderer))
  (let ((nest 0) (depth 0))
    (loop for node in (kernel-renderer-nodes k)
	  for type = (node-type node)
	  if (eql type :FOR)
	    do (incf depth)
	  if (eql type :ENDFOR)
	    do (decf depth)
	  end
	  do (setf nest (max nest depth)))
    nest))

(defmethod find-outermost-for ((r kernel-renderer))
  (let ((nodes (kernel-renderer-nodes r)))
    (loop for node in nodes
	  if (eql (node-type node) :FOR)
	    do (return-from find-outermost-for node))))
;; [TODO] Delete kernel-renderer-outermost-loop-eq
(defmethod kernel-renderer-outermost-loop-eq ((a kernel-renderer) (b kernel-renderer))
  "Compares two outermost loops in the a and b"
  (and
   nil
   ;; [TODO] Fuse Nested Loops that ISL failed to fuse.
   ;; There should be much better way to determine this.
   (multiple-value-bind (a b) (values (find-outermost-for a) (find-outermost-for b))
     (and a b
	  (equal (getattr a :idx) (getattr b :idx))
	  (expr-eq (getattr a :upfrom) (getattr b :upfrom))
	  (expr-eq (getattr a :below) (getattr b :below))
	  (expr-eq (getattr a :by) (getattr b :by))
	  (eql (getattr a :scope) (getattr b :scope))))))

(defmethod separate-scalar-and-vector-parts ((a kernel-renderer))
  "Return: (values scalar-nodes vector-nodes) if nodes are:
T0(...)
T1(...)
for (...) {
  T2(...)
  T3(...)
}
T0 T1 are scalar-nodes, T2, T3 are vector-nodes.
"
  (let ((nodes (kernel-renderer-nodes a))
	(scalars)
	(vectors))
    (loop with loop-mode-p = nil
	  for node in nodes
	  if (eql (node-type node) :FOR)
	    do (setf loop-mode-p t)
	  end
	  if loop-mode-p
	    do (push node vectors)
	  else
	    do (push node scalars))
    (values (nreverse scalars) (nreverse vectors))))

;; [TODO] Remove
(defmethod merge-two-loops ((a kernel-renderer) (b kernel-renderer) (poly Polyhedral))
  "Merges two iteration. the relations between a and b can be formulated as:
```
T0(t=0, i)  // a-scal
for(int i=0; i<10; i++) {
  T1(t=1, i) // a-vec
}
T2(t=2, 0) // b-scal
for(int i=0; i<10; i++) {
  T2(t=3, i) // b-vec
}
```
We consider shuffling these nodes which never violates lexiographical order.
"
  (let ((lex (poly-lex-table poly))
	(a-outermost (find-outermost-for a))
	(b-outermost (find-outermost-for b)))
    (when (and a-outermost b-outermost)
      (unless (equal (getattr a-outermost :idx) (getattr b-outermost :idx))
	(return-from merge-two-loops)))
    (labels ((nodes->lex (nodes)
	       (loop for node in nodes
		     if (eql (node-type node) :FUNCALL)
		       collect (gethash (getattr node :idx) lex)))
	     (lex-dep-ok (a b)
	       "for all: (a1, a2, ...) > (b1, b1, ...)"
	       (<= (apply #'max (nodes->lex a)) (apply #'min (nodes->lex b))))
	     (scal-p (nodes) (null (find :FOR nodes :key #'node-type)))
	     (remloop (nodes)
	       (loop for node in nodes
		     unless (or (find (node-id node) `(,a-outermost ,b-outermost) :key #'node-id)
				(and (eql (node-type node) :ENDFOR)
				     (find (getattr node :idx) `(,a-outermost ,b-outermost) :key #'(lambda (x) (getattr x :idx)))))
		       collect node))
	     (apply-merge (&rest timestamps &aux (insert-at (or (position-if (compose #'not #'scal-p) timestamps) -1)))
	       (unless (= insert-at -1)
		 (assert (every (compose #'not #'scal-p) (nthcdr insert-at timestamps))))
	       (append
		(loop for nodes in timestamps
		      for nth upfrom 0
		      if (scal-p nodes)
			append nodes
		      if (= nth insert-at)
			append (list a-outermost)
		      if (not (scal-p nodes))
			append (remloop nodes))
		(list (r/endfor (getattr a-outermost :idx))))))
      ;; [TODO] There are more fusable (or relocation) iteration patterns.
      (multiple-value-bind (a-scal a-vec) (separate-scalar-and-vector-parts a)
	(multiple-value-bind (b-scal b-vec) (separate-scalar-and-vector-parts b)
	  ;; For simplicity, we consider all 4 patterns:
	  (cond
	    ((and (null a-scal) (null b-scal) a-vec b-vec)
	     ;; When T0, T2 is null. We can merge them as long as a-vec/b-vec are satisfying lex-dep.
	     (cond
	       ((lex-dep-ok a-vec b-vec) (apply-merge a-vec b-vec))
	       ((lex-dep-ok b-vec a-vec) (apply-merge b-vec a-vec))
	       (T nil)))
	    ((and a-scal b-scal (null a-vec) (null b-vec))
	     ;; As well as on the around case.
	     (cond
	       ((lex-dep-ok a-scal b-scal) (apply-merge a-scal b-scal))
	       ((lex-dep-ok b-scal a-scal) (apply-merge b-scal a-scal))
	       (T nil)))
	    ((and a-scal (null b-scal) a-vec b-vec)
	     ;; T2=null, there is no separating node -> fuse always
	     (when (lex-dep-ok a-vec b-vec) ;; (lex-dep-ok a-scal a-vec) is always true since originally scheduled so.
	       (apply-merge a-scal a-vec b-vec)))
	    ((and (null a-scal) a-vec b-scal b-vec)
	     ;; T=0 is null, try relocate T2 into T0, (if it fails, they cannot be fused)
	     ;; a-vec     b-scal
	     ;; b-scal -> a-vec
	     ;; b-vec     b-vec
	     (cond
	       ((lex-dep-ok b-scal a-vec)
		(apply-merge b-scal a-vec b-vec))
	       ((lex-dep-ok a-vec b-scal)
		(apply-merge b-scal a-vec b-vec))))
	    ((and a-scal b-scal a-vec b-vec)
	     (when (and
		    (lex-dep-ok b-scal a-vec)
		    (lex-dep-ok a-scal b-scal))
	       (apply-merge a-scal b-scal a-vec b-vec)))))))))

(defmethod swap-two-loops ((a kernel-renderer) (b kernel-renderer) (poly Polyhedral))
  "Sorts two iteration by lexiographical order dependencies."
  (let ((lex (poly-lex-table poly)))
    (labels ((nodes->lex (nodes)
	       (loop for node in nodes
		     if (eql (node-type node) :FUNCALL)
		       collect (gethash (getattr node :idx) lex)))
	     (lex-dep-ok (a b)
	       "for all: (a1, a2, ...) > (b1, b1, ...)"
	       (<= (apply #'max (nodes->lex a)) (apply #'min (nodes->lex b)))))
      ;; [TODO] There are more fusable (or relocation) iteration patterns.
      (or
       (null (kernel-renderer-nodes a))
       (null (kernel-renderer-nodes b))
       (lex-dep-ok (kernel-renderer-nodes a) (kernel-renderer-nodes b))))))

(defun sort-kernel-renderers (kernel-renderers polyhedral)
  (flet ((s (x y) (swap-two-loops x y polyhedral)))
    (sort kernel-renderers #'s)))

(defun fuse-outermost-loops (polyhedral blueprints)
  "Fuses two rendering groups whose outermost loops are the completely equivalent.
This fusion is only applied in the original polyhedral group, (which is assumed to no circular deps, and time series deps are in straight)
So we asssume all pairs of loop fusion are always valid.
e.g.:
for(int i=0; i<10; i++) {
  // some element-wise operations (1)
}
for(int i=0; i<10; i++) {
  // some element-wise operations (2)
}
are fused into:
for(int i=0; i<10; i++) {
  // some element-wise operations (1)
  // some element-wise-operations (2)
}
This may reduce the number of extra allocation for tmpvar.
"
  (declare (type polyhedral polyhedral)
	   (type list blueprints))
  (let ((blueprints (sort-kernel-renderers blueprints polyhedral)))
    (remove-duplicates
     (loop with last-visited = (car blueprints)
	   for blueprint in `(,@(cdr blueprints) nil)
	   for merged = (when blueprint (merge-two-loops last-visited blueprint polyhedral))
	   collect
	   (if (and blueprint merged (kernel-renderer-outermost-loop-eq last-visited blueprint))
	       (progn
		 (setf last-visited
		       (make-kernel-renderer
			:nodes merged
			:nth (kernel-renderer-nth last-visited)))
		 last-visited)
	       (prog1
		   last-visited
		 (setf last-visited blueprint))))
     :key #'kernel-renderer-nth)))

(defmethod collapse-loop ((kr kernel-renderer) (poly polyhedral))
  "Collapses the loop in the kernel to get more parallelization/vectorization opportunities, e.g.:
for(int i=0; i<10; i++) {
  for(int j=0; j<10; j++) {
    T0(i, j);
  }
}
is transformed into:
for(int i=0; i<10*10; i++) {
  T0(i);
}
"
  kr)

(defun r/packed-funcall (funcall unrolled idx size)
  ;; :_packed t
  ;; :_unrolled (a list of actually unrolled funcall)
  ;; :_metadata ((idx1 . size) (idx . size) ...)
  (let ((new-funcall (copy-node funcall)))
    (setf (getattr new-funcall :_packed) t
	  (getattr new-funcall :_unrolled) unrolled
	  (getattr new-funcall :_metadata) (append (getattr new-funcall :_metadata) (list (cons idx size))))
    new-funcall))

(defun unroll-upfrom (below unroll-by &key (1p t))
  ;; unroll_by * (mod size unroll-by)
  (let* ((below (if 1p below (if (numberp below) (1+ below) (make-expr :+ below (make-expr :const 1)))))
	 (rem (if (and (numberp below) (numberp unroll-by)) (mod below unroll-by) (make-expr :% below unroll-by))))
    (if (and (numberp rem) (numberp below))
	(make-expr :const (- below rem))
	(make-expr :- below rem))))

(defun decf-below (expr idx unroll-by)
  (trivia:ematch expr
    ((Expr :op :<= :x (Expr :op :const :x (trivia:guard id (equal id idx))) :y (Expr :op :const :x x))
     (if (and (numberp x) (numberp unroll-by))
	 (make-expr :<= idx (- x unroll-by))
	 (make-expr :<= (make-expr :+ idx (make-expr :const unroll-by)) (make-expr :const x))))
    ((Expr :op :< :x (Expr :op :const :x (trivia:guard id (equal id idx))) :y (Expr :op :const :x x))
     (if (and (numberp x) (numberp unroll-by))
	 (make-expr :<= idx (- x unroll-by))
	 (make-expr :<= (make-expr :+ idx (make-expr :const unroll-by)) (make-expr :const x))))))

(defmethod pack-loop-funcall ((kr kernel-renderer) (poly polyhedral) (unroll-by fixnum))
  "Groups the iteration into several packed-funcall.
packed-funcall can be transformed into: Tiling/Vectorizing/Unrolling at the renderer level.
for (int i=0; i<a; i++) {
  T0(c0);
}
Is transformed into:
for (int i=0; i<(a-UNROLL_BY); i+=UNROLL_BY) {
        [packed_funcall]
                 { T0(c0+0)
  T0'(c0, 0~4) = { T0(c0+1)
                 { T0(c0+2)
                 { T0(c0+3)
}
for (int i=a - (mod a UNROLL_BY); i<a; i+=1) {
 T0(c0) // Loop Reminder (TODO: Optimize Index Computation)
}
"
  (when (= 0 (ctx:getenv :PACKED)) (return-from pack-loop-funcall kr))
  (when (= 1 unroll-by) (return-from pack-loop-funcall kr))
  (labels ((static-unroll-p (node &aux (idx (getattr node :idx)))
	     (and
	      (eql (node-type node) :FOR)
	      ;; If the shape is static (it is known whether reminder part occurs before compilation)
	      ;; If mod(loop_size, unroll_by) = 0, :GLOBAL loops can be packed.
	      (getattr node :coincident)
	      (trivia:match (getattr node :upfrom)
		((Expr :op :const :x (trivia:guard x (and (numberp x) (= x 0)))) t))
	      (trivia:match (getattr node :by)
		((Expr :op :const :x (trivia:guard x (and (numberp x) (= x 1)))) t))
	      (trivia:match (getattr node :below)
		((Expr :op :<= :x (Expr :op :const :x (trivia:guard id (equal id idx))) :y (Expr :op :const :x (trivia:guard x (numberp x))))
		 (= 0 (mod (1+ x) unroll-by)))
		((Expr :op :< :x (Expr :op :const :x (trivia:guard id (equal id idx))) :y (Expr :op :const :x (trivia:guard x (numberp x))))
		 (= 0 (mod x unroll-by))))))
	   (unroll-reminder-upfrom (node &aux (idx (getattr node :idx)))
	     ;; Return -> new :upfrom
	     (and
	      (eql (node-type node) :FOR)
	      ;; If the shape is symbolic, reminder part is computed at runtime.
	      ;; thus cannot vectorize the outermost loop. (TODO: Fix)
	      (eql (getattr node :scope) :LOCAL)
	      (getattr node :coincident)
	      (trivia:match (getattr node :upfrom)
		((Expr :op :const :x (trivia:guard x (and (numberp x) (= x 0)))) t))
	      (trivia:match (getattr node :by)
		((Expr :op :const :x (trivia:guard x (and (numberp x) (= x 1)))) t))
	      (trivia:match (getattr node :below)
		((Expr :op :<= :x (Expr :op :const :x (trivia:guard id (equal id idx))) :y (Expr :op :const :x x))
		 (and
		  (if (numberp x)
		      (>= (1+ x) unroll-by)
		      t)
		  (unroll-upfrom x unroll-by :1p t)))
		((Expr :op :< :x (Expr :op :const :x (trivia:guard id (equal id idx))) :y (Expr :op :const :x x))
		 (and
		  (if (numberp x)
		      (>= x unroll-by)
		      t)
		  (unroll-upfrom x unroll-by :1p t))))))
	   (make-unroll (idx n-unroll base-funcall)
	     (r/packed-funcall
	      base-funcall
	      (loop for node in (or (getattr base-funcall :_unrolled) (list base-funcall))
		    append
		    (loop for nth upfrom 0 below n-unroll
			  collect
			  (flet ((mapper (x)
				   (if (and (or (symbolp x) (stringp x)) (string= x idx))
				       (format nil "(~a+~a)" x nth)
				       x)))
			    (r/funcall
			     (getattr node :name)
			     (map
			      'list
			      #'(lambda (x &aux (x (copy-expr x))) (expr-recursive-replace x #'mapper) x)
			      (getattr node :args))
			     :unroll-offsets (append (getattr node :unroll-offsets) (list (cons idx nth)))))))
	      idx
	      n-unroll))
 	   (unroll-valid-p (nodes)
	     (every #'(lambda (x) (find (node-type x) `(:FOR :ENDFOR :FUNCALL))) nodes))
  	   (subseq-loops (nodes start-id idx
			  &aux (nodes (nthcdr (or (position start-id nodes :key #'node-id) (error "~a is not found" idx)) nodes)))
	     (loop with flag = t
		   for n in nodes
		   if (and flag (eql (node-type n) :ENDFOR) (equal (getattr n :idx) idx))
		     collect (copy-node n) and do (setf flag nil)
		   else if flag collect (copy-node n)))
	   (replace-body (nodes replace-with start end)
	     (loop with replace-mode = nil
		   for n in nodes
		   if (eql (node-id n) start)
		     append (progn (setf replace-mode t) replace-with)
		   else if (eql (node-id n) end)
			  do (setf replace-mode nil)
		   else if (not replace-mode) collect n))		   
	   (unroll (nodes tgt-for)
	     (let* ((base-for (copy-node tgt-for))
		    (body (or
			   (subseq-loops nodes (node-id tgt-for) (getattr tgt-for :idx))
			   (return-from unroll nodes)))
		    (reminder-body (copy-list body))
		    (start-id (node-id (car body)))
		    (end-id   (node-id (car (last body))))
		    (reminder)
		    (static-p (static-unroll-p tgt-for))
		    (reminder-upfrom (unroll-reminder-upfrom tgt-for)))
	       (when (null (unroll-valid-p body)) (return-from unroll nodes))
	       (when (and (null static-p) (null reminder-upfrom)) (return-from unroll nodes))
	       (setf (getattr tgt-for :by) (make-expr :const unroll-by)
		     (car body) tgt-for)
	       (loop for nth upfrom 0
		     for node in body
		     if (eql (node-type node) :FUNCALL)
		       do (setf (nth nth body) (make-unroll (getattr tgt-for :idx) unroll-by node)))
	       (when (null static-p)
		 (setf (getattr base-for :by) (make-expr :const 1)
		       (getattr base-for :upfrom) reminder-upfrom
		       (getattr tgt-for :below) (decf-below (getattr tgt-for :below) (getattr tgt-for :idx) unroll-by)
		       (car reminder-body) base-for
		       reminder reminder-body))
	       (replace-body nodes (append body reminder) start-id end-id))))
    (let ((iterations
	    (loop with depth = 0
		  for node in (kernel-renderer-nodes kr)
		  if (eql (node-type node) :FOR)
		    collect
		    (cons depth node) and do (incf depth)
		  else if (eql (node-type node) :ENDFOR) do
		    (decf depth))))
      (dolist (iter (sort iterations #'> :key #'car))
	(setf (kernel-renderer-nodes kr) (unroll (kernel-renderer-nodes kr) (cdr iter)))))
    kr))

(defun render-graph-from-polyhedral (polyhedral nodes)
  "Finalizes an rendering graph to use based on nodes."
  (declare (type list nodes) (type polyhedral))
  (let ((kernels) (outputs))
    (loop with nest = 0
	  with nest-by-loop = 0
	  for node in nodes
	  for type = (node-type node)
	  if (find type `(:FOR :IF))
	    do (push node kernels) (incf nest)
	  else if (find type `(:ENDFOR :ENDIF)) do
	    (if (and (= 1 nest) (some #'(lambda (x) (eql (node-type x) :FOR)) kernels))
		(progn (decf nest) (push node kernels) (push (nreverse kernels) outputs) (setf kernels nil))
		(progn (decf nest) (push node kernels)))
	  else do
	    (push node kernels))
    (push (nreverse kernels) outputs)
    (funcall (if (= 0 (ctx:getenv :SERIALIZE))
		 #'fuse-outermost-loops
		 #'(lambda (x y) (declare (ignore x)) y))
	     polyhedral
	     (loop for out in (reverse outputs)
		   for nth upfrom 0
		   collect (make-kernel-renderer :nodes out :nth nth)))))

(defmethod ->render-graph ((group Group))
  (when (group-polyhedron group)
    (render-graph-from-polyhedral (group-polyhedron group) (graph-nodes (group-render-graph group)))))

;; ~~ Memory Latency Optimizations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defmethod update-buffer-as-scalar ((node Node) mutated-list domain-space)
  (flet ((mutate-scalar-buffer (id buffer expr read-p)
	   (if (= (buffer-nrank buffer) 0)
	       buffer
	       (let ((new (make-const-buffer (buffer-dtype buffer))))
		 ;; depend-idx-list: required to compute the position of unrollment. e.g.: val_5 -> val_5_0, val_5_1, val_5_2, ...
		 (setf (buffer-depend-idx-list new)
		       (loop for shape in (buffer-shape buffer)
			     for nth upfrom 0
			     for view = (nth nth (buffer-views buffer))
			     for dom = (nth nth domain-space)
			     do (assert (eql (expr-op dom) :Const) () "Schedule is not a constant? (TODO: Add unrolling for this case ...)")
			     if (or (eql 0 (expr-x dom)) (and view (nth 3 view)))
			       collect nil
			     else
			       collect (expr-x dom)))
		 (when (and expr read-p) (expr-recursive-settype expr id new))
		 new))))
    (macrolet ((f (ids types read-p)
		 `(loop for val in (,ids node)
			for type in (,types (read-type-relay node))
			for nth upfrom 0
			if (find val mutated-list) do
			  (setf (nth nth (,types (read-type-relay node)))
				(mutate-scalar-buffer val type (when (eql (node-type node) :EXPR) (getattr node :EXPR)) ,read-p)))))
      (f node-reads relay-reads t)
      (f node-writes relay-writes t))))
;; ~~ Post-MultiExpr ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;; ** Post-MultiExpr is WIP**
(defmethod expr-apply-post-multiexpr ((group group) (graph graph) (node node) funcall->domain nodeid->pipeline)
  (assert (eql (node-type node) :EXPR))
  (flet ((get-domain-from-funcall (node)
	   (assert (eql (node-type node) :FUNCALL))
	   (gethash (or (gethash (node-id node) nodeid->pipeline) (error "~a is not defined in nodeid->pipeline." node)) funcall->domain)))
    (let ((reads (node-reads node)))
      (dolist (r (cdr reads))
	;; Domainが完全に同じ or 部分的に同じを最適化の設定で変更可能にする
	;; esp: Embeddingでは100*102回の余分な比較が増える
	))))

(defmethod expr-index-components-p ((node node))
  (assert (eql (node-type node) :EXPR))
  (and
   (getattr node :EXPR)
   (eql (expr-op (getattr node :EXPR)) :INDEX-COMPONENTS)))

(defmethod domain-equal ((for1 node) (for2 node))
  (assert (eql (node-type for1) :FOR))
  (assert (eql (node-type for2) :FOR))

  )

(defmethod domain-permutation ((fc1 Node) (fc2 Node))
  "
```
for (int c0 = 0; c0 <= 9; c0 += 1) {
  T0(c0, 0); ----------------------------|
}                                        |
                                         | Moving
for (int c0 = 0; c0 <= 9; c0 += 1) {     |
  T1 (0, c0); <--------------------------|
}
```
When moving a node in T0 into T1, the operation is represented as:
`permute_all_buffers_in_funcall(T0, domain_permutation(T0, T2))`
"
  (assert (eql (node-type fc1) :FUNCALL))
  (assert (eql (node-type fc2) :FUNCALL))
  (assert (= (length (getattr fc1 :args)) (length (getattr fc2 :args))))
  (flet ((zero-p (x)
	   (and
	    (eql (expr-op x) :Const)
	    (eql 0 (expr-x x)))))
    (let ((initial-range (range 0 (length (getattr fc1 :args)))))
      (macrolet ((swap (a b)
		   `(let ((tmp (nth ,a initial-range)))
		      (setf (nth ,a initial-range) (nth ,b initial-range)
			    (nth ,b initial-range) tmp))))
	(loop for arg in (getattr fc1 :args)
	      for nth upfrom 0
	      unless (zero-p arg) do
		(let ((pos (position arg (getattr fc2 :args) :test #'expr-eq)))
		  (unless pos (return-from domain-permutation)) ;; Failed (fc2 is not a subset of fc1)
		  (swap pos nth))))
      initial-range)))

(defun %permute (buffer permute &aux (buffer (copy-buffer buffer)))
  (assert (= (length permute) (buffer-nrank buffer)))
  (setf (buffer-shape buffer) (permute-list permute (buffer-shape buffer))
	(buffer-stride buffer) (permute-list permute (buffer-stride buffer))
	(buffer-views buffer) (and (buffer-views buffer) (every #'identity (buffer-views buffer)) (permute-list permute (buffer-views buffer))))
  buffer)

(defmethod expr-apply-index-component-globalize ((group group) (graph graph) (node node) funcall->domain nodeid->pipeline)
  "Propagate Index-Components"
  ;; not working
  (flet ((get-domain-from-funcall (node)
	   (gethash (or (gethash (node-id node) nodeid->pipeline) (error "~a is not defined in nodeid->pipeline." node)) funcall->domain))
	 (node->funcall (node)
	   (let ((idx (gethash (node-id node) nodeid->pipeline)))
	     (find idx (graph-nodes (group-render-graph group)) :key #'(lambda (x) (getattr x :idx))))))
    (loop with domain = (get-domain-from-funcall node)
          for reads in (cdr (node-reads node))
	  for rt in (cdr (relay-reads (read-type-relay node)))
	  for ic  = (id->value graph reads)
	  if (and ic (eql (node-type ic) :EXPR)) do
	    (when (expr-index-components-p ic)
	      (let* ((ic-expr (copy-expr (getattr ic :EXPR))))
		(when (eql *default-order* :row)
		  ;; [aI + b][K]
		  (flet ((zero-p (x)
			   (and
			    (eql (expr-op x) :Const)
			    (eql 0 (expr-x x)))))
		    ;; [2x+2]
		    ;; [2, 4, 6, 8, 10][1:4]
		    (setf (expr-y (expr-x ic-expr)) rt
			  (expr-y ic-expr)
			  (map 'list #'(lambda (x dom) (if (zero-p dom) (make-const 0 nil) (make-const x nil)))
			       ;; Consider T0[0, 0, _gid2, 0] -> T1[_gid1, _gid2, _gid3, _gid4] migration.
			       (buffer-stride rt) (getattr (node->funcall ic) :args)))
		    (expr-graft-after (getattr node :EXPR) (car (node-writes ic)) ic-expr)
		    (setf (relay-reads (read-type-relay node))
			  (loop with ic-t = (car (relay-writes (read-type-relay ic)))
				for r in (node-reads node)
				for rt1 in (relay-reads (read-type-relay node))
				if (eql r (car (node-reads ic)))
				  collect rt
				else
				  collect rt1)
		          (node-reads node)
			  (loop for r in (node-reads node)
				if (eql r (car (node-reads ic)))
				  collect rt
				else
				  collect r)))))))))

(defmethod post-simplify-multiexpr ((group Group))
  "Applies further multiexpr grouping to the scheduled mp.
Consider this fake-python kernel representing Embedding Op.

(Unoptimized)
```python
def main(val_35, val_54, val_48, val_31, val_37, val_41) {
  for _gid0 in range(0, 1000): # sentence_len
    for _gid1 in range(0, 101): # batch_size
      for _gid2 in range(0, 100): # vocab_size
        val_48[_gid1, _gid0, _gid2] = _gid2 == val_37[_gid1, _gid0] # T0(_gid1, _gid0, _gid2)
      for _gid2 in range(0, 102): # embedding_dim
        val_54_acc = 0.0 # T1(_gid0, _gid1, _gid2)
        for _gid3 in range(0, 100): # vocab_size
          val_35[_gid1, _gid0, _gid3, _gid2] = val_31[_gid3, _gid2] if val_48[_gid1, _gid0, _gid3] else 0.0 # T2(_gid0, _gid1, _gid2, _gid3)
        for _gid3 in range(0, 100): # vocab_size
           val_54_acc += val_35[_gid1, _gid0, _gid3, _gid2] # T3(_gid0, _gid1, _gid2, _gid3)
        val_54[_gid1, _gid0, _gid2] = val_54_acc
}
```

Here, T2 and T0 are the strongly-connected components, and the domain T0 is a subset of T2. In default, ISL Scheduler (Pluto) won't fuse these two domains because this will produce a dead execution loop. However, in general, making this cache often results in lower performance especially in deep learning inference. So we will fuse them.

We refer to \"fusable\" components as:

- T2の各Readを読む
- T2の他のReadとweakly-connectedがNILになるEXPRは操作を適用できる
- Reductionには操作を適用しない
- readはoutputとしてlabelされている
- Graphで直接の依存があるペア
- id->usersのカウントが1である (directly connected)

(Optimized)
```python
def main(val_35, val_54, val_48, val_31, val_37, val_41)
  for _gid0 in range(0, 1000): # sentence_len
    for _gid1 in range(0, 101): # batch_size
      for _gid2 in range(0, 102): # embedding_dim
        val_54_acc = 0.0
        for _gid3 in range(0, 100): # vocab_size?
          val_54_acc += val_31[_gid3, _gid2] if _gid3 == val_37[_gid1, _gid0]) else 0.0
        val_54[_gid1, _gid0, _gid2] = val_54_acc
```
Note: This is a trade-off: it minimizes the number of DRAM accesses, which generally improves performance, but it ignores the number of Domain executions, which can create Dead Loop.
"
  (when (group-realize-on-vm group) (return-from post-simplify-multiexpr))
  (let ((graph (groups->graph (list group)))
	(render-graph (group-render-graph group))
	(funcall->domain (make-hash-table))
	(nodeid->pipeline (make-hash-table))
	(pipeline (poly-pipeline (group-polyhedron group))))
    (flet ((simple-p (node) (find (node-type node) `(:FOR :ENDFOR :FUNCALL))))
      (unless (every #'simple-p (graph-nodes render-graph)) (return-from post-simplify-multiexpr))
      (maphash
       #'(lambda (ts graph)
	   (dolist (n (graph-nodes graph))
	     (setf (gethash (node-id n) nodeid->pipeline) ts)))
       pipeline)
      (loop with domains = nil
	    for node in (graph-nodes render-graph)
	    if (eql (node-type node) :FOR)
	      do (push node domains)
	    if (eql (node-type node) :ENDFOR)
	      do (setf domains (remove (getattr node :idx) domains :key #'(lambda (x) (getattr x :idx)) :test #'equalp))
	    if (eql (node-type node) :FUNCALL)
	      do (when (gethash (getattr node :idx) funcall->domain)
		   (when (>= (ctx:getenv :JIT_DEBUG) 1)
		     (warn "The node ~a appeared in the scheduled graph more than twise times and thus cannot apply post-simplify multiexpr." node))
		   (return-from post-simplify-multiexpr))
		 (setf (gethash (getattr node :idx) funcall->domain) (reverse domains))))
    
    (macrolet ((do-funcall (form)
		 `(loop for node in (graph-nodes render-graph)
			if (eql (node-type node) :FUNCALL) do
			  (dolist (node (graph-nodes (gethash (getattr node :idx) pipeline)))
			    (when (eql (node-type node) :EXPR)
			      ,form)))))
      ;; Globalize Index-Components (its 100% no benefits of making a cache)
      ;; [TODO]
      ;; (do-funcall (expr-apply-index-component-globalize group graph node funcall->domain nodeid->pipeline))
      ;; (do-funcall (expr-apply-post-multiexpr group graph node funcall->domain nodeid->pipeline))
      )))
