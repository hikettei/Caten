(in-package :caten/api)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *cached-functions* (make-hash-table :test #'equal))
  (defun find-from-cache-function (backend op dtype order) (gethash (list backend op dtype order) *cached-functions*))
  (defun register-cached-function (backend op dtype order runtime) (setf (gethash (list backend op dtype order) *cached-functions*) runtime))
  (defun create-blueprint-from-body (dtype order lambda-list graph-f &aux (*default-order* order))
    (let* ((*default-float* (if (caten/common.dtype:dtype/floatp dtype)    dtype *default-float*))
	   (*default-uint*  (if (caten/common.dtype:dtype/uintegerp dtype) dtype *default-uint*))
	   (*default-int*   (if (caten/common.dtype:dtype/integerp dtype)  dtype *default-int*))
	   (outputs (multiple-value-list (apply graph-f (collect-initargs-names lambda-list))))
           (blueprint (caten outputs)))
      blueprint))
  ;; [TODO] Remove cffi-prefix?
  (defmacro caten/defun[T] ((name cffi-prefix &key (dtypes)) lambda-list &body body)
    (declare (type string cffi-prefix))
    ;; Note: C-c C-c and create a new placeholder for the function by using gensym.
    (let ((op-dispatcher (intern (format nil "~a/~a~a" name cffi-prefix (gensym)) "KEYWORD")))
      `(progn
         (defun ,name (dtype ,@lambda-list)
           (assert (member dtype ',dtypes) () "The cacheable function ~a does not support the dtype ~a." ',name dtype)
           (let* ((key (list (ctx:getenv :BACKEND) ',op-dispatcher dtype *default-order*))
                  (cached-runtime (apply #'find-from-cache-function key)))
             (if cached-runtime
                 (flet ((-> (x) (if (tensor-p x) (tensor-buffer x) x)))
                   (forward cached-runtime ,@(loop for name in (collect-initargs-names lambda-list) append `(',name (-> ,name)))))
                 (let ((runtime (create-blueprint-from-body dtype *default-order* ',lambda-list (lambda (,@(collect-initargs-names lambda-list)) ,@body))))
                   (register-cached-function (nth 0 key) (nth 1 key) (nth 2 key) (nth 3 key) runtime)
                   (flet ((-> (x) (if (tensor-p x) (tensor-buffer x) x)))
                     (forward runtime ,@(loop for name in (collect-initargs-names lambda-list) append `(',name (-> ,name))))))))))))
  (defmacro caten/defun[all] ((name cffi-prefix) lambda-list &body body)
    `(caten/defun[T] (,name ,cffi-prefix :dtypes (:float64 :float32 :float16 :bfloat16 :uint64 :int64 :uint32 :int32 :uint16 :int16 :uint8 :int8)) (,@lambda-list) ,@body))
  (defmacro caten/defun[float] ((name cffi-prefix) lambda-list &body body)
    `(caten/defun[T] (,name ,cffi-prefix :dtypes (:float64 :float32 :float16 :bfloat16)) (,@lambda-list) ,@body))
  (defmacro caten/defun[int] ((name cffi-prefix) lambda-list &body body)
    `(caten/defun[T] (,name ,cffi-prefix :dtypes (:int64 :uint32 :int32 :uint16 :int16 :uint8 :int8)) (,@lambda-list) ,@body))
  (defmacro caten/defun[uint] ((name cffi-prefix) lambda-list &body body)
    `(caten/defun[T] (,name ,cffi-prefix :dtypes (:uint64 :uint32 :uint16 :uint8)) (,@lambda-list) ,@body)))
