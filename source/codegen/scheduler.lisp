(defpackage #:caten/codegen/scheduler
  (:documentation "
The `caten/codegen/scheduler` is responsible for assigining the execution order of the computation graph in the aasm.
Occasionally they merges or rewrites a view in order to schedule multiple nodes into the same schedule if possible.

The function `graph-schedule` is an entry point, and takes a shape-inferred aasm graph as input, performs scheduling, and returns a schedule graph (called Schedule-Graph) whose each node is composed of Schedule-Item.

One Schedule-Item corresponds to one kernel in GPU, `graph-schedule` must ensure that each item is merged only within the bounds that can be lowered into a single kernel.")
  (:use :cl :caten/air :caten/avm :caten/codegen/shape-inference :caten/codegen/expr :caten/codegen/helpers :caten/codegen/rewriting-rules)
  (:import-from :caten/aasm #:JITAble)
  (:export #:Group #:make-group #:graph-schedule #:*function-name-maxlen* #:group->schedule))

(in-package #:caten/codegen/scheduler)

(defparameter *function-name-maxlen* 64 "Restricts the maximum length of the function name autogenerated by the compiler.")

(defnode (:GRAPH :Schedule-Item) ()
         "
Schedule-Item is an intermidate object to represent a one kernel in GPU.

```
f = cache_name or name
write_ids = f(*[storage_id_dst], *[dynamic_shape], *[inputs])
                      ^ can be modified by the memory-planner
```

It has a unique `name`, and `cache-name`. If `cache-name` was assigned, the compiler will fail to compile this schedule-item and reuse the kernel named `cache-name` instead.

In order to lowering the computation graph as the foreign language, `items` must be consisted of JITAble operations (except for special irs and :allocate). If it qualifies, `jitable` is set to T.

Otherwise, the scheduled items are relocated to the compiled avm directly. Specifially, if the item was :ALLOCATE, :allocated-p is set to T.

- blueprint[list] is a lowered schedule-item
- polyhedral[list] is a Polyhedral IR obtained by lowering blueprint
- auto-schedule-p[list] is set to T if it is worth to run auto-scheduler. (If there is a symbolic incremental, loop is not an affine and cannot run isl scheduler)
- items[list] are the scheduled items
- items-to-cache[list] are the copies of items but having the unique read/write. It is used to determine the equivalence of the two schedule-items.
- rank[fixnum] is the highest rank of the iteration space.
- storage-id-src[list] is the list of the storage-id of the source buffer (optimized by running memory-planner)
- storage-id-dst[list] is the list of the storage-id of the destination buffer (optimized by running memory-planner)
- namespace[list] a list of symbols appeared in the items. It is used to map a new blueprint from the cached blueprint.
"
         :slots
         ((blueprint :type list :initform nil)
          (polyhedral)
          (jitable :type boolean)
          (allocate-p :type boolean)
          (auto-schedule-p :type boolean)
          (name :type symbol) (cache-name :type symbol)
          (items :type list) (items-to-cache :type list)
          (rank :type fixnum) (reduce-dims :type list)
          (read-types :type list) (write-types :type list)
          (reference-counters :type list)
          (storage-id-src :type list)
          (storage-id-dst :type list)
          (dynamic-shapes :type list)
          (rendered-object :type string)
          (compiled-object :type list)
          (namespace :type list)))

(defmethod print-node (node (id (eql :Schedule-Item)))
  (flet ((r (x y)
           (apply
            #'concatenate
            'string
            (butlast
             (loop for nth upfrom 0 below (max (length x) (length y))
                   for x1 = (nth nth x)
                   for y1 = (nth nth y)
                   if (or (eql x1 y1) (null y1))
                     append (list (format nil "~a" x1) ", ")
                   else
                     append (list (format nil "~a[~a]" x1 y1) ", "))))))
    (format nil "{ ~a } : [ ~a <- ~a where lowered-p=~a ~a]"
            (if (getattr node :allocate-p)
                "Allocate"
                (if (getattr node :jitable)
                    " KERNEL "
                    "  VMOP  "))
            (r (node-writes node) (getattr node :storage-id-dst))
            (if (getattr node :allocate-p)
                (subseq (node-reads (car (getattr node :items))) 0 (getattr (car (getattr node :items)) :nrank))
                (r (node-reads node) (getattr node :storage-id-src)))
            (if (getattr node :blueprint)
                "t" "nil")
            (if (getattr node :allocate-p)
                ""
                (if (getattr node :cache-name)
                    (format nil ":cache-name=~a :name=~a" (getattr node :cache-name) (getattr node :name))
                    (format nil ":name=~a" (getattr node :name)))))))
;; ~~ Some Helpers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defun schedule-item-initialize-namespace (si)
  (declare (type node si))
  (assert (eql (node-type si) :Schedule-Item))
  (setf (getattr si :namespace) (nodes-create-namespace (getattr si :items))))

(defun pname (name)
  (cl-ppcre:regex-replace-all
   "PAUSE/"
   (cl-ppcre:regex-replace-all "-" (cl-ppcre:regex-replace-all "GRAPH/" (princ-to-string name) "") "_")
   ""))

(defmethod jitable-p ((node Node))
  (and
   (null (find (node-type node) `(:ALLOCATE :PAUSE/BACKWARD)))
   (typep (node-attr node) 'JITAble)))

(defmethod graph-shape-inferred-p ((graph Graph))
  (dolist (n (graph-nodes graph))
    (when (and (jitable-p n) (null (getattr n :_type_relay :allow-undefined t))) (return-from graph-shape-inferred-p nil)))
  t)

(defmethod node-reduce-axes ((node Node))
  (when (getattr node :reduction :allow-undefined t)
    (let ((write-buffer (car (relay-writes (read-type-relay node)))))
      (let ((out
              (loop for v in (buffer-views write-buffer)
                    for s in (buffer-shape write-buffer)
                    if (fourth v)
                      collect s
                    else
                      collect nil)))
        ;; Returns uncollapsed rank list
        (when (some #'identity out) out)))))
;; ~~ Group ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defstruct Group
  (predecessor '() :type list) ;; = group-reads
  (successor '() :type list)   ;; = group-writes
  (key (gensym) :type symbol)
  (reduce-dims nil :type list)
  (items nil :type list))

(defmethod verify-group ((group Group))
  (when (find :Allocate (group-items group) :key #'node-type)
    (assert (= (length (group-items group)) 1) () "Allocate should be scheduled standalone")))

(defmethod make-unique-schedule-name ((group Group))
  "Names an unique and readable kernel name for human."
  (let ((names-func)
        (module-names)
        (seen))
    (dolist (item (group-items group))
      (if (and (typep (node-attr item) 'JITAble) (car (getattr item :_lowering_history))) ;; JITAble nodes have a lowering history
          (multiple-value-bind (name id) (values (caar (getattr item :_lowering_history)) (cdar (getattr item :_lowering_history)))
            ;; history = (module_name, module_id)
            (when (null (find id seen))
              (push id seen)
              (push (pname name) module-names)))
          (push (pname (node-type item)) names-func)))
    (let ((key
            (with-output-to-string (out)
              (princ "FUSED" out)
              (dolist (n (or module-names names-func))
                (format out "_~a" (ensure-string-as-compilable (princ-to-string n)))))))
      (when (> (length key) *function-name-maxlen*)
        (setf key (subseq key 0 *function-name-maxlen*)))
      (gensym key))))

(defmethod group-get-type ((group Group))
  (let* ((last (nodes-write-to (group-items group))) ;; [TODO] This should be group-successor
         (node (when last (find (car last) (group-items group) :key #'node-writes :test #'find))))
    (when node (car (relay-writes (read-type-relay node))))))

(defmethod group-rank ((group Group) &aux (buff (group-get-type group)))
  (and buff (buffer-nrank buff)))

(defun group-assert-rank (group r1 r2 view &aux (rank (max r1 r2)))
  (loop for item in (group-items group)
        do (loop for typ in (append (relay-reads (read-type-relay item)) (relay-writes (read-type-relay item)))
                 for nth upfrom 0
                 unless (or (null typ) (= 0 (buffer-nrank typ)))
                   do (assert (= rank (buffer-nrank typ)) ()
                              "Rank mismatch: (expected from ~a -> ~a)~%view=~a~%buffer:~%~a~%group~%~a"
                              (min r1 r2) rank view typ group))))
;; ~~ View Rewriting ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defmethod group-items-st-rewriter ((group Group) f mask)
  (dolist (item (group-items group))
    (when (and
           (eql (node-type item) :INDEX-COMPONENTS)
           (not (= (length mask) (length (cdr (node-reads item))))));; (cdr (node-reads index-components)) also represents for the stride
      (setf (node-reads item)
            (append
             (list (car (node-reads item)))
             (loop with s = (cdr (node-reads item))
                   for m in mask
                   if m collect 1 else collect (pop s)))))
    (loop for typ in (relay-reads (read-type-relay item))
          for nth upfrom 0
          unless (or (null typ) (= 0 (buffer-nrank typ)))
            do (setf (nth nth (relay-reads (read-type-relay item))) (or (funcall f typ) typ)))
    (loop for typ in (relay-writes (read-type-relay item))
          for nth upfrom 0
          unless (or (null typ) (= 0 (buffer-nrank typ)))
            do (setf (nth nth (relay-writes (read-type-relay item))) (or (funcall f typ) typ)))))

(defun merge-permute-from-mask (permute mask)
  (when (>= (length permute) (length mask))
    (return-from merge-permute-from-mask permute))
  (let ((val (uiop:symbol-call :caten/apis :compute-new-permute permute mask)))
    (assert (= (length val) (length mask)) () "permute=~a mask=~a val=~a" permute mask val)
    val))

(defun apply-view-fusor (tgt-rank mask group &key (permute))
  ;; T = broadcasted, NIL = old axes2
  (group-items-st-rewriter
   group
   #'(lambda (typ)
       (when (= (buffer-nrank typ) tgt-rank)
         (let ((typ (copy-buffer typ)))
           (let ((shp (copy-list (buffer-shape typ)))
                 (str (copy-list (buffer-stride typ)))
                 (views (copy-list (buffer-views typ))))
             (setf (buffer-shape typ)
                   (loop for b in mask
                         if b collect 1 else collect (or (pop shp) 1))
                   (buffer-stride typ)
                   (loop for b in mask
                         if b collect 0 else collect (or (pop str) 1))
                   (buffer-views typ)
                   (loop for b in mask
                         if b collect `(0 1 1 t) else collect (pop views))
                   (buffer-nrank typ) (length (buffer-shape typ))
                   (buffer-inferred-permute typ) (if (buffer-inferred-permute typ)
                                                     (merge-permute-from-mask (buffer-inferred-permute typ) mask)
                                                     (merge-permute-from-mask (range 0 (buffer-nrank typ)) mask)))
             (when (and permute (buffer-inferred-permute typ) (= (length permute) (buffer-nrank typ))
                        (not (equal permute (buffer-inferred-permute typ))))
               (setf (buffer-shape typ) (permute-list permute (buffer-shape typ))
                     (buffer-stride typ) (permute-list permute (buffer-stride typ))
                     (buffer-views typ) (permute-list permute (buffer-views typ))))
             ;; Consumed all masks?
             (assert (= (buffer-nrank typ) (length mask)))
             typ))))
   mask))

(defmethod apply-index-component-fusion ((group Group) permute)
  "Permutes the strides of :INDEX-COMPONENTS in the group in the group"
  (dolist (item (group-items group))
    (when (and (eql (node-type item) :INDEX-COMPONENTS) (= (length permute) (length (cdr (node-reads item)))))
      (setf (cdr (node-reads item)) (permute-list permute (cdr (node-reads item)))))))
;; ~~ Shape Checking ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defun broadcastable-p (prev new)
  (let ((prev-shape (copy-list (buffer-shape prev)))
        (new-shape  (copy-list (buffer-shape new))))
    (let ((p (loop for p in prev-shape if (not (eql p 1)) collect p))
          (n (loop for n in new-shape if (not (eql n 1)) collect n)))
      (equal p n))))

(defun buffer-mergeable-p (g b1 b2)
  (flet ((lazy-eq (a b)
           (or (eql a 1) (eql b 1) (eql a b)
               (and (symbolp a) (symbolp b) (expr-scalar-equivalent-p (expr-from-graph a g) (expr-from-graph b g))))))
    (every #'lazy-eq (buffer-shape b1) (buffer-shape b2))))

(defmethod identify-view-type ((view Node))
  (assert (eql :VIEW (node-type view)))
  (when (some #'identity (getattr view :broadcast)) (return-from identify-view-type :broadcast))
  (when (not (equal (getattr view :permute) (range 0 (getattr view :nrank))))
    (return-from identify-view-type :permute))
  (flet ((shrink-p (size view)
           (assert (= (length view) 4) () "not a view")
           (multiple-value-bind (from to by broadcast) (apply #'values view)
             (assert (null broadcast))
             (or
              (not (eql from 0))
              (not (eql to size))
              (not (eql by 1))))))
    (let* ((base-buffer (car (relay-reads (read-type-relay view))))
           (views (buffer-views (car (relay-writes (read-type-relay view))))))
      (when (and
             (= (buffer-nrank base-buffer) (getattr view :nrank))
             (some #'shrink-p (buffer-shape base-buffer) views))
        (return-from identify-view-type :shrink)))
    :reshape))
;; ~~ Scheduler ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defun make-graph-edge-map (graph)
  "Computes the in-degrees and out-degrees of the graph. Nodes located after the :PAUSE/BACKWARD must be realized after :PAUSE/BACKWARD."
  (declare (optimize (speed 3)) (type graph graph))
  ;; in-degrees:  NODE_ID -> (list (cons node view) ...)
  ;; out-degrees  NODE_ID -> (list node ...)
  (let ((in-degrees (make-hash-table)) (out-degrees (make-hash-table))
        (backward (find :PAUSE/BACKWARD (the list (graph-nodes graph)) :key #'node-type))
        (backward-pos (position :PAUSE/BACKWARD (the list (graph-nodes graph)) :key #'node-type)))
    (declare (type hash-table in-degrees out-degrees))
    (flet ((butseen (list views)
             (assert (every #'(lambda (x) (<= (length (the list x)) 1)) views))
             (loop for l in list
                   for view in views
                   for v = (id->value graph l)
                   if (and v (symbolp l)) collect (cons v view))))
      (loop for node in (graph-nodes graph)
            for nth fixnum upfrom 0 do
              (assert (= (length (the list (node-reads node))) (length (the list (getattr node :_read_views)))))
              (setf (gethash (node-id node) in-degrees) (butseen (node-reads node) (getattr node :_read_views)))
              (when (and backward backward-pos (> nth backward-pos))
                ;; If PAUSE/BACKWARD is defined, nodes placed after it must be realized after :PAUSE/BACKWARD.
                (push (cons backward nil) (gethash (node-id node) in-degrees))
                (push node (gethash (node-id backward) out-degrees)))
              (dolist (r (gethash (node-id node) in-degrees))
                (let ((r (car r))) ;; r = node
                  (when (null (find (node-id node) (the list (gethash (node-id r) out-degrees)) :key #'node-id))
                    (push node (gethash (node-id r) out-degrees)))))))
    (list in-degrees out-degrees)))
                 
(defstruct (Schedule-Context
            (:conc-name ctx-)
            (:constructor make-schedule-context (graph &aux (io-degree (make-graph-edge-map graph)))))
  (graph graph :type graph)
  (in-degrees (car io-degree) :type hash-table)
  (out-degrees (second io-degree) :type hash-table)
  (realize (make-hash-table) :type hash-table)
  (node->group (make-hash-table) :type hash-table)
  (node-id->parent-id (make-hash-table) :type hash-table)
  (queue nil :type list)
  (restart-cache (make-hash-table) :type hash-table)
  (restart-cache1 (make-hash-table) :type hash-table))

(defmethod group->schedule-item ((group Group) (ctx Schedule-Context))
  (let ((reads (group-predecessor group))
        (writes (group-successor group))
        (allocate-p (find :Allocate (group-items group) :key #'node-type))
        (no-symbolic-incremental-p t)
        (full-scalar-p t) (rank 0) (id2type (make-hash-table)))
    ;; Ensure there's no symbolic incremental for the auto scheduler.
    (dolist (node (group-items group))
      (loop for r in (append (node-reads node) (node-writes node))
            for rt in (append (relay-reads (read-type-relay node)) (relay-writes (read-type-relay node)))
            do (setf (gethash r id2type) rt)
            if rt do
              (when (> (buffer-nrank rt) 0)
                (setf full-scalar-p nil))
              (setf rank (max rank (buffer-nrank rt)))
              (dolist (v (buffer-views rt))
                (when (and v (third v) (symbolp (third v))) ;; v=(upfrom below by broadcast_p)
                  (setf no-symbolic-incremental-p nil)))))
    (make-node :GRAPH :Schedule-Item writes reads :name (make-unique-schedule-name group)
               :jitable (and (every #'jitable-p (group-items group)) (null full-scalar-p))
               :allocate-p (when allocate-p t)
               :auto-schedule-p (and no-symbolic-incremental-p (null full-scalar-p))
               :storage-id-dst writes
               :storage-id-src reads
               :read-types (map 'list #'(lambda (x) (gethash x id2type)) reads)
               :write-types (map 'list #'(lambda (x) (gethash x id2type)) writes)
               :reference-counters
               ;; TODO: Rethink the reference counter
               (map
                'list
                #'(lambda (x)
                    (if (find x (graph-outputs (ctx-graph ctx)))
                        -1
                        (length (ctx-children ctx (id->value (ctx-graph ctx) x)))))
                (append reads writes))
               :rank rank
               :reduce-dims (group-reduce-dims group)
               :items (group-items group)
               :items-to-cache (nodes-apply-static-gensym (map 'list #'copy-node (group-items group))))))

(defmethod ctx-children ((ctx Schedule-Context) (node node)) (gethash (node-id node) (ctx-out-degrees ctx)))
(defmethod ctx-parents ((ctx Schedule-Context) (node node)) (map 'list #'car (gethash (node-id node) (ctx-in-degrees ctx))))
(defmethod ctx-parent-views ((ctx Schedule-Context) (node node)) (map 'list #'cdr (gethash (node-id node) (ctx-in-degrees ctx))))
(defmethod ctx-set-realize ((ctx Schedule-Context) node)
  (assert (eql (node-id node) (ctx-find-group-id ctx (node-id node))) () "The node ~a is already scheduled?" node)
  (setf
   (gethash (node-id node) (ctx-node->group ctx))
   (make-group :predecessor (nodes-depends-on (list node)) :successor (nodes-write-to (list node)) :reduce-dims (node-reduce-axes node) :items (list node))
   (gethash (node-id node) (ctx-realize ctx)) t))
(defmethod ctx-realize-p ((ctx Schedule-Context) node) (gethash (node-id node) (ctx-realize ctx)))
(defmethod ctx-sync-queue ((ctx Schedule-Context))
  (declare (optimize (speed 3)))
  (setf (ctx-queue ctx)
        (loop for node in (graph-nodes (ctx-graph ctx))
              if (and
                  (null (ctx-realize-p ctx node)) ;; node is not realized and all parents are realized
                  (every #'(lambda (x) (ctx-realize-p ctx x)) (ctx-parents ctx node)))
                collect node)))
(defmethod ctx-append-queue ((ctx Schedule-Context) nodes)
  (declare (optimize (speed 3)))
  (loop for node in nodes
        if (and (null (ctx-realize-p ctx node))
                (every #'(lambda (x) (ctx-realize-p ctx x)) (ctx-parents ctx node)))
          do (push node (ctx-queue ctx))))
(defmethod ctx-get-group ((ctx Schedule-Context) node)
  (or
   (gethash (ctx-find-group-id ctx (node-id node)) (ctx-node->group ctx))
   (error "The node ~a is not yet scheduled!" node)))
(defmethod ctx-try-get-group ((ctx Schedule-Context) node)
  (gethash (ctx-find-group-id ctx (node-id node)) (ctx-node->group ctx)))
(defmethod ctx-register-new-group ((ctx Schedule-Context) (tgt node) (parent node))
  (setf (gethash (node-id tgt) (ctx-node-id->parent-id ctx)) (node-id parent)))
(defmethod ctx-find-group-id ((ctx Schedule-Context) (tgt symbol))
  (declare (optimize (speed 3)))
  (labels ((explore (id &aux (val (gethash id (ctx-node-id->parent-id ctx))))
             (if val
                 (if (not (eql (the symbol val) id))
                     (explore val)
                     (error "Group Fusion from x -> x is detected. ~a" id))
                 id)))
    (explore tgt)))

(defun compute-group-write-to (group-items graph)
  "Lists all write dependencies used by non-group-items nodes originated from the group-items."
  (declare (type list group-items) (type graph graph) (optimize (speed 3)))
  (let ((read-except-for-items
          (remove-duplicates
           (append
            (graph-outputs graph)
            (loop with region = (map 'list #'node-id group-items)
                  for node in (graph-nodes graph)
                  if (null (find (node-id node) region))
                    append (node-reads node)))))
        (write-set (remove-duplicates (apply #'append (map 'list #'node-writes group-items)))))
    (declare (type list read-except-for-items write-set))
    (loop for w of-type symbol in write-set
          if (find w read-except-for-items)
            collect w)))

(defmethod ctx-node-force-realize-p ((ctx Schedule-Context) (a node) (b node))
  "Detects the following pattern in the DAG. In order to merge a and b in the same group, c must be grouped to a or b.
[a] ──────> d ──────>[b]
  \       /         /
   \     /         /
    \   /         /  ... (recursively)
     \ /         /
      c ──────> e
          ^ If groups are separated at here, a and b cannot be merged.
This method returns T if every children are scheduled in the same group as a or b. (= fusable).
Otherwise, returns NIL. (= not fusable)"
  (declare (optimize (speed 3)))
  (let ((a-children (ctx-children ctx a))
        (a-group (ctx-get-group ctx a))
        (b-group (ctx-get-group ctx b)))
    (every
     #'identity
     (loop with items = (append (group-items a-group) (group-items b-group))
           for a-child in a-children
           for scheduled-p = (if (find (node-id a-child) items :key #'node-id) t nil)
           for closed-p = (or scheduled-p
                              (and
                               ;; a must be realized before b
                               (ctx-realize-p ctx a-child)
                               ;; a and c must be in the same group for example.
                               (eql (group-key (ctx-get-group ctx a-child)) (group-key a-group))
                               (ctx-node-force-realize-p ctx a-child b)))
           if closed-p
             collect t
           else
             do (return-from ctx-node-force-realize-p nil)))))

(defmethod groups-are-injective-p ((tgt-group Group) (parent-group Group))
  ;; If the output of parent-group is also used by other groups, don't merge it.
  (every #'(lambda (x) (find x (group-predecessor tgt-group))) (group-successor parent-group)))

(defmethod group-chase-down-reduction-p ((ctx Schedule-Context) (group Group) (restart-point Node))
  "Chace down until found reduction is succeed => return T"
  (let ((successor (group-successor group)))
    (loop for succ in successor
          for node = (id->value (ctx-graph ctx) succ)
          if node do
            (loop for child in (ctx-children ctx node)
                  for child-group = (ctx-try-get-group ctx child)
                  if (null child-group)
                    do (setf (ctx-queue ctx) (append (ctx-queue ctx) (list restart-point))) ;; not yet scheduled => wait until group is constructed.
                       (when (null (gethash (node-id restart-point) (ctx-restart-cache ctx)))
                         (setf (ctx-queue ctx) (append (ctx-queue ctx) (list restart-point))
                               (gethash (node-id restart-point) (ctx-restart-cache ctx)) t))
                       (return-from group-chase-down-reduction-p t)
                  if (group-reduce-dims child-group)
                    do (return-from group-chase-down-reduction-p t)))
    nil))
;; [TODO] Simplify the algorithm. at least :permute in apply-view-fusor may not be necessary.
(defmethod groups-rewrite-views-in-the-same-space ((parent-group Group) (tgt-group Group) view)
  "If you want to schedule parent-group and tgt-group in the same space, this method fixes the view to be compatible in the same kernel. If failed, returns NIL."
  (symbol-macrolet ((->ng (return-from groups-rewrite-views-in-the-same-space nil))
                    (->ok (return-from groups-rewrite-views-in-the-same-space t)))
    (let* ((r1 (group-rank tgt-group)) (r2 (group-rank parent-group))
           (read-type (group-get-type parent-group))
           (self-type (group-get-type tgt-group))
           (c (< r1 r2)))
      (when (null self-type)->ng)
      (if (broadcastable-p read-type self-type) ;; simpliy broadcastable
          (let* ((base-1 (loop for s in (buffer-shape (if c self-type read-type)) if (eql s 1) collect s))
                 (mask (map 'list
                            #'(lambda (x)
                                (if (eql x 1)
                                    (if base-1
                                        (progn (pop base-1) nil)
                                        t)
                                    nil))
                            (buffer-shape (if c read-type self-type)))))
            (assert (some #'identity mask))
            (when (not (= (+ (count-if #'identity mask) (min r1 r2)) (max r1 r2)))->ng)
            (apply-view-fusor (min r1 r2) mask tgt-group :permute (and view (getattr view :permute)))
            (apply-view-fusor (min r1 r2) mask parent-group :permute (and view (getattr view :permute)))
            (when (and view (getattr view :permute))
              (apply-index-component-fusion parent-group (getattr view :permute)))
            (group-assert-rank tgt-group r1 r2 view)
            (group-assert-rank parent-group r1 r2 view)
            ->ok)
          (if (and view (some #'identity (getattr view :broadcast)))
              (let ((mask (getattr view :broadcast)))
                (declare (type list mask))
                (when (not (= (length mask) (max r1 r2)))
                  (setf mask (map 'list #'fourth (buffer-views (if c read-type self-type)))))
                (when (not (= (length mask) (max r1 r2)))->ng)
                (when (not (= (+ (count-if #'identity mask) (min r1 r2)) (max r1 r2)))->ng)
                (apply-view-fusor (min r1 r2) mask tgt-group :permute (and view (getattr view :permute)))
                (apply-view-fusor (min r1 r2) mask parent-group :permute (and view (getattr view :permute)))
                (when (and view (getattr view :permute))
                  (apply-index-component-fusion parent-group (getattr view :permute)))
                (group-assert-rank tgt-group r1 r2 view)
                (group-assert-rank parent-group r1 r2 view)
                ->ok)
              ->ng)))))

(defmethod groups-reduce-permute-p ((tgt-group Group) (parent-group Group) &aux (dims (or (group-reduce-dims tgt-group) (group-reduce-dims parent-group))))
  "reduction -> permute -> reduction is not allowed in the group. If such path exists, this method returns T."
  (labels ((reduce-p (node)
             (getattr node :reduction :allow-undefined t))
           (broadcast-conflicts-p (node)
             (loop for read in (relay-reads (read-type-relay node))
                   for views = (buffer-views read)
                   if (some #'identity views) do
                     (when (not (= (length views) (length dims)))
                       (return-from groups-reduce-permute-p nil))
                     ;; (assert (= (length views) (length dims)) () "views=~a dims=~a~%~a~%~a" views dims tgt-group parent-group)
                     (loop for broadcastable in dims
                           for view in views
                           if (and (null broadcastable) (fourth view))
                             do (return-from broadcast-conflicts-p t)))
             nil))
    (let ((bounds (append (group-successor tgt-group) (group-successor parent-group)))
          (g (apply #'make-graph (append (group-items parent-group) (group-items tgt-group))))
          (seen))
      (setf (graph-outputs g) bounds g (->fast-graph g))
      (labels ((explore (id &key (first-reduce-p nil) (double-reduce-p nil))
                 (when (find id seen) (return-from explore))
                 (let ((node (id->value g id)))
                   (when (null node) (return-from explore))
                   (push id seen)
                   (setf double-reduce-p (or double-reduce-p (and first-reduce-p (reduce-p node)))
                         first-reduce-p (or first-reduce-p (reduce-p node)))
                   (when (and double-reduce-p (broadcast-conflicts-p node))
                     (return-from groups-reduce-permute-p t))
                   (mapc #'(lambda (x) (explore x :first-reduce-p first-reduce-p :double-reduce-p double-reduce-p))
                         (node-reads node)))))
        ;; reduction -> permute -> reduction is not allowed.
        (mapc #'(lambda (x) (setf seen nil) (explore x)) (group-successor tgt-group)))
      nil)))

(defmethod group-compute-reduce-pattern ((parent-group Group) (tgt-group Group))
  (if (and (group-reduce-dims parent-group) (group-reduce-dims tgt-group))
      :case3
      (if (group-reduce-dims parent-group)
          :case1
          :case2)))

(defmethod ctx-get-scheduled-groups ((ctx Schedule-Context))
  (let ((keys (remove-duplicates (map 'list #'(lambda (x) (ctx-find-group-id ctx x)) (alexandria:hash-table-keys (ctx-node->group ctx))))))
    (remove-duplicates (loop for k in keys collect (gethash k (ctx-node->group ctx))) :key #'group-key)))

(defmethod ctx-fusable-case1-p ((ctx Schedule-Context) entry-points)
  ;; node-group-dims =T -> always T
  (let ((groups (ctx-get-scheduled-groups ctx))
        (seen))
    (labels ((explore (id)
               (when (find id seen) (return-from explore nil))
               (let ((item (find id groups :key #'group-successor :test #'find)))
                 (when (null item) (return-from explore nil))
                 (when (group-reduce-dims item)
                   (return-from ctx-fusable-case1-p t))
                 (mapc #'explore (group-predecessor item)))))
      (mapc #'explore entry-points)
      nil)))

(defun group-mergeable-p (ctx restart-point tgt-group parent-group view)
  "
```
Graph: parent-group -> [view] -> tgt-group
```
Returns T if merging parent-group and tgt-group is possible. Sometime rewrites view/buffers to compute two kernel without allocating an extra buffer.
"
  (declare (type Schedule-Context ctx) (type Group tgt-group parent-group) (type (or null node) view) (type node restart-point))
  (when view (assert (eql (node-type view) :VIEW)))
  (symbol-macrolet ((->ng (return-from group-mergeable-p nil))
                    (->ok (return-from group-mergeable-p t)))
    (flet ((force-realize-p (nodes) (some #'(lambda (x) (null (jitable-p x))) nodes)))
      ;; :Allocate, VMOP, etc are scheduled standalone.
      (when (force-realize-p (group-items tgt-group))->ng)
      (when (force-realize-p (group-items parent-group))->ng))
    ;; Reductions with the different axes cannot be merged.
    (when (and (group-reduce-dims tgt-group) (group-reduce-dims parent-group))
      (when (not (equal (group-reduce-dims tgt-group) (group-reduce-dims parent-group)))
        ->ng))
    (let ((reduce-p (identity (or (group-reduce-dims parent-group) (group-reduce-dims tgt-group))))
          (pattern (group-compute-reduce-pattern parent-group tgt-group))
          (r1 (group-rank tgt-group)) (r2 (group-rank parent-group)))
      ;; float _acc_0 = 0.0f;
      ;; for (...) {
      ;;   _acc_0 = ...;
      ;; }
      ;; self = _acc_0;
      ;; // tgt-group is here if after-reduction-p is T
      (when (and view (eql (identify-view-type view) :SHRINK)) ->ng) ;; TODO(hikettei) Merge Contiguous+Shrink
      (when (or (= r1 0) (= r2 0))->ok) ;; always merge scalar+anything
      (when reduce-p ;; If tgt or parent has a reduction:
        ;; Here, you have to consider the following three cases:
        ;;         Parent     TGT              [Parent+TGT]
        ;; case1 Reduce    + Injective (e.g.: Matmul+ReLU)
        ;; case2 Injective + Reduce    (e.g.: Load(0.0)+WMMA, Matmul+GeLU+Matmul)
        ;; case3 Reduce    + Reduce    (e.g.: Normalization, Softmax, VarStd Fusion)
        (when (and (eql pattern :case1) (group-chase-down-reduction-p ctx tgt-group restart-point))
          ;; Think after merging tgt-group+reduction is scheduled.
          ;; If restart_cache is set to T, the child is scheduled but not merged with tgt-group. => proceed to the next stage.
          (when (null (gethash (node-id restart-point) (ctx-restart-cache1 ctx))) ;; todo no skip
            (setf (ctx-queue ctx) (append (ctx-queue ctx) (list restart-point))
                  (gethash (node-id restart-point) (ctx-restart-cache1 ctx)) t)
            ->ng))
        (when (groups-reduce-permute-p tgt-group parent-group) ->ng) ;; Reduce -> Permute -> Reduce is not fusable.
        (if (= r1 r2)
            (when (buffer-mergeable-p (ctx-graph ctx) (group-get-type tgt-group) (group-get-type parent-group))
              ;; [TODO] apply-view-fusor here?
              ->ok)
            (let ((optimal-p
                    (or (eql pattern :case1)
                        (eql pattern :case3)
                        ;; If case2 (no reduction+no reduction) there could be better merging pair, if the path has a reduced group.
                        (null (ctx-fusable-case1-p ctx (group-predecessor tgt-group))))))
              (when (and optimal-p (groups-rewrite-views-in-the-same-space parent-group tgt-group view))->ok)))
        ->ng)
      ;; Otherwise, merging non-reduction nodes to create a block of elwise ops group. (e.g.: a sequence of activations)
      ;; fuse/rewrite _read_views and buffers sometime.
      ;; 1. Injective + Same Ranks
      (when (= r1 r2)
        (when (buffer-mergeable-p (ctx-graph ctx) (group-get-type parent-group) (group-get-type tgt-group))
          ;; Reject :MOVE+:MOVE fusion if view is provided.
          (when (and view (= (length (group-items parent-group)) (length (group-items tgt-group)) 1)
                     (eql :MOVE (node-type (car (group-items parent-group))))
                     (eql :MOVE (node-type (car (group-items tgt-group)))))
            ->ng)
          (let ((permute (and view (getattr view :permute))))
            (when permute (apply-view-fusor (length permute) (loop repeat (length permute) collect nil) parent-group :permute permute)))
          ->ok)
        ->ng)
      ;; 2. Injective + Different Ranks
      (when (group-chase-down-reduction-p ctx tgt-group restart-point)->ng) ; If tgt-group is used by the reduction => better to merge it with that.
      ;; Needed to fuse (!add (10 10 10) (sin (10 10)))
      (if (groups-rewrite-views-in-the-same-space parent-group tgt-group view)
          ->ok
          ->ng))))

(defun graph-breadth-first-schedule (ctx &key (no-serialize-p (= 0 (the fixnum (ctx:getenv :SERIALIZE)))) (stashed nil))
  (declare (type Schedule-Context ctx) (type list stashed) (optimize (speed 3)))
  ;; Initialize a priority queue of all nodes ready to be scheduled.
  (ctx-sync-queue ctx)
  (flet ((s (&aux (changed-p nil))
           (loop while (ctx-queue ctx)
                 for tgt of-type Node = (pop (ctx-queue ctx))
                 for children = (ctx-children ctx tgt)
                 for parents  = (ctx-parents ctx tgt)
                 for parent-views = (ctx-parent-views ctx tgt) do
                   ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   ;; parents[0] parents[1] parents[2] ...
                   ;;      \      |      /
                   ;;           [TGT]
                   ;;       /     |      \
                   ;; children[0] children[1] children[2] ...
                   ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   ;; 1. In order to schedule "TGT", all parents must be scheduled first.
                   ;; 2. children are scheduled after "TGT" and their parents of each children are scheduled.
                   (when (not (ctx-realize-p ctx tgt))
                     (ctx-set-realize ctx tgt)
                     (ctx-append-queue ctx children)) ; tgt may make some children ready to be scheduled.
                   (loop for p in parents
                         for parent-view in (map 'list #'car parent-views)
                         for parent-group = (ctx-get-group ctx p)
                         for tgt-group = (ctx-get-group ctx tgt) ;; tgt-group would be updated if tgt is merged
                         unless (eql (group-key parent-group) (group-key tgt-group)) do
                           (let ((force-realize-p (ctx-node-force-realize-p ctx p tgt))
                                 (injective-p (groups-are-injective-p tgt-group parent-group)))
                             (if (and no-serialize-p force-realize-p injective-p (group-mergeable-p ctx tgt tgt-group parent-group parent-view))
                                 (progn
                                   ;; remove(parent_group) and tgt_group += parent-group
                                   (ctx-register-new-group ctx p tgt)
                                   (setf changed-p t
                                         (group-items tgt-group) (append (group-items parent-group) (group-items tgt-group))
                                         (group-reduce-dims tgt-group) (or (group-reduce-dims tgt-group) (group-reduce-dims parent-group))
                                         (group-predecessor tgt-group)
                                         (remove-duplicates
                                          (loop with write-set = (apply #'append (map 'list #'node-writes (group-items tgt-group)))
                                                for p in (append (group-predecessor parent-group) (group-predecessor tgt-group))
                                                unless (find (the symbol p) (the list write-set)) ; p is not written by tgt-group => p is written by other group.
                                                  collect p))
                                         (group-successor tgt-group) (compute-group-write-to (group-items tgt-group) (ctx-graph ctx))))
                                 (unless (and force-realize-p injective-p) ;; waiting until other scheduling processes are finished.
                                   (when (null (find (the symbol (node-id tgt)) stashed :key #'node-id))
                                     ;; stash until descendant scheduling are completed
                                     (push tgt stashed)))))))
           changed-p))
    (s)
    (loop while stashed do
      (setf (ctx-queue ctx) stashed stashed nil)
      (unless (s) (loop-finish))))
  (let ((keys (remove-duplicates (map 'list #'(lambda (x) (ctx-find-group-id ctx x)) (alexandria:hash-table-keys (ctx-node->group ctx))))))
    (remove-duplicates (loop for k in keys collect (gethash k (ctx-node->group ctx))) :key #'group-key)))

(defun group-distribute-dynamic-shape-load (group ctx)
  "Consider the following targeting graph and scheduling results.
`X = LOAD(A)` appears only once in the graph, so it also appears only once in the Schedule-Item.
```
Graph:
X = LOAD(A)
L = sin(X)
M = cos(X)
```
Schedule1:
```
X = LOAD(A)
L = sin(X)
```
Schedule2:
```
M = cos(X)
```
Since LOAD is a zero-cost operation, it can be shared across multiple schedule items to make the generated kernel clean.
This function will put a copy of LOAD if some of nodes in group-items stop right before LOAD.
"
  (declare (type group group) (type Schedule-Context ctx) (optimize (speed 3)))
  (when (every #'jitable-p (group-items group)) ;; this is only the case for jitable kernel
    (loop for predecessor in (group-predecessor group)
          for item = (id->value (ctx-graph ctx) predecessor)
          for alloc = (and item (id->value (ctx-graph ctx) (car (node-reads item))))
          if (and item alloc (eql (node-type item) :LOAD) (eql (node-type alloc) :Allocate)
                  (= 0 (buffer-nrank (car (relay-writes (read-type-relay item)))))
                  (= 0 (the fixnum (getattr alloc :nrank))))
            do (setf (group-predecessor group) (remove predecessor (group-predecessor group)))
               (push item (group-items group))))
  group)

(defun apply-move-after-reduction (schedule-graph)
  (declare (type graph schedule-graph) (optimize (speed 3)))
  (labels ((%newtype (buffer)
             (caten/avm:make-buffer
              (buffer-nrank buffer)
              (loop for s in (buffer-shape buffer)
                    for nth fixnum upfrom 0
                    for v = (nth nth (buffer-views buffer))
                    if (and (listp v) (fourth v)) ;; broadcasted
                      collect 1
                    else
                      collect s)
              (buffer-stride buffer)
              (buffer-dtype buffer)
              (loop for s in (buffer-shape buffer)
                    for nth fixnum upfrom 0
                    for v = (nth nth (buffer-views buffer))
                    if (and (listp v) (fourth v))
                      collect `(0 1 1 t)
                    else
                      collect v)))
           (%jstore (w a b base-type)
             (make-node :Buffer :MOVE (list w) (list a b)
                        :_type_relay
                        (caten/codegen/shape-inference:make-inferred-type
                         (list (%newtype base-type) (%newtype base-type))
                         (list (%newtype base-type)))))
           (acc (id) (intern (format nil "~(~a~)_acc" id)))
           (r (si &aux (g (apply #'make-graph (getattr si :items))))
             (dolist (node (graph-nodes g))
               ;; reduced but no users in the group: This is now allowed. Adding :MOVE
               (when (and (getattr node :reduction :allow-undefined t)
                          ;; write-to needs to be broadcasted.
                          (node-writes-broadcasted-p node)
                          (null (id->users g (car (node-writes node))))) ;; no users in a group
                 (let ((base-id (car (node-reads node)))
                       (write-id (car (node-writes node)))
                       (acc-id (acc (car (node-reads node)))))
                   (setf (node-writes node) (list acc-id))
                   ;; val_3 = val_3_acc
                   ;; ```
                   ;; float val_3 = 0.0;               float val_3 = 0.0;
                   ;; for (...) val_4 = val_3+1.0  =>  for (...) val_3_acc = val_3+1.0;
                   ;; ```                              val_4[0] = val_3_acc;
                   (push
                    (%jstore write-id base-id acc-id (car (relay-writes (read-type-relay node))))
                    (getattr si :items)))))))
    (mapc #'r (graph-nodes schedule-graph))))

(defun graph-schedule (graph)
  "
```
(graph-schedule graph)
```
Creates a schedule-graph(FastGraph) from the given `graph`."
  (declare (type Graph graph) (optimize (speed 3)))
  (assert (graph-nodes graph) () "graph-schedule: Nothing to schedule?")
  (assert (graph-shape-inferred-p graph) () "graph-schedule: Run the shape inference first!")
  (assert (null (find :VIEW (the list (graph-nodes graph)) :key #'node-type)) () "graph-schedule: :VIEW should not be appeared here. (run caten/codegen/rewriting-rules:apply-rewriting-rules first.)")
  (assert (graph-outputs graph) () "graph-schedule: Graph without graph-outputs cannot be scheduled!")
  (when (= 2 (the fixnum (ctx:getenv :DOT))) (->dot graph :title "Graph [Before Scheduling]"))
  (when (>= (the fixnum (ctx:getenv :JIT_DEBUG)) 4)
    (format t "[graph-schedule] graph before scheduling:~%")
    (pprint-graph graph))
  (let* ((ctx (make-schedule-context graph))
         (groups (graph-breadth-first-schedule ctx))
         (groups (map 'list #'(lambda (x) (group-distribute-dynamic-shape-load x ctx)) groups))
         (schedule-graph (apply #'make-graph (map 'list #'(lambda (x) (group->schedule-item x ctx)) groups))))
    (setf (graph-outputs schedule-graph) (graph-outputs graph) schedule-graph (->fast-graph schedule-graph)) ; Convert the schedule graph into FastGraph
    (mapc #'verify-group groups)
    (apply-move-after-reduction schedule-graph) ;; :reduction T cannot be an output of schedule item.
    (when (>= (the fixnum (ctx:getenv :JIT_DEBUG)) 3)
      (format t "[graph-schedule] scheduled graph:~%")
      (pprint-graph schedule-graph))
    (when (= 2 (the fixnum (ctx:getenv :DOT)))
      (->dot schedule-graph :title "Schedule Graph"))
    ;; Assert all nodes in the base-graph was scheduled correctly.
    (let ((nodes (map 'list #'node-id (apply #'append (map 'list #'group-items groups)))))
      (dolist (n (graph-nodes graph)) (setf nodes (remove (node-id n) nodes)))
      (assert (null nodes) () "graph-schedule: Nodes ~a are not scheduled." nodes))
    (mapc #'schedule-item-initialize-namespace (graph-nodes schedule-graph)) ;; create a unique and readable naming for each kernel.
    schedule-graph))
