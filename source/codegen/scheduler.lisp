(defpackage #:caten/codegen/scheduler
  (:documentation "
`caten/codegen/scheduler` is responsible for partitioning a (huge amount of!) computation graph into several smaller subgraphs with the same iteration space.

`graph-schedule` as en entry point, it receives a graph of `caten/aasm` created by running `caten/apis/iseq.lisp`, and returns a graph of `Schedule-Item`.
One Schedule-Item corresponds to one kernel in GPU. Therefore, in general, the more computation grouped in the same group, the better, in term of the memory-locality. Loops may be distributed elsewhere, but never fused except for `recursive-create-group`.")
  (:use :cl :caten/air :caten/codegen/expr)
  (:import-from :caten/aasm #:JITAble)
  (:import-from
   #:caten/air
   #:defnode
   #:Node
   #:node-type
   #:node-attr
   #:FastGraph
   #:graph-outputs
   #:id->value
   #:id->users
   #:copy-node)
  (:import-from
   #:caten/avm
   #:Buffer
   #:copy-buffer
   #:buffer-dtype
   #:buffer-shape
   #:buffer-stride
   #:buffer-views
   #:buffer-nrank
   #:buffer-inferred-permute)
  (:import-from
   #:caten/codegen/shape-inference
   #:mergeable-view-p
   #:read-type-relay
   #:relay-reads
   #:relay-writes
   #:relay-read-iters
   #:relay-write-iters
   #:buffer-merge-dims
   #:iteration-space
   #:iteration-space-shape
   #:iteration-space-strides
   #:iteration-space-views
   #:iteration-space-procedure)
  (:import-from
   #:caten/codegen/helpers
   #:range
   #:permute-list
   #:nodes-depends-on
   #:nodes-write-to
   #:ensure-string-as-compilable)
  (:import-from
   #:caten/codegen/rewriting-rules
   :nodes-apply-static-gensym)
  (:export
   #:Group
   #:make-group
   #:graph-schedule
   #:*function-name-maxlen*
   #:group->schedule
   #:.view))

(in-package #:caten/codegen/scheduler)

(defparameter *function-name-maxlen* 64 "Restricts the maximum length of the function name autogenerated by the compiler.")

(defnode (:GRAPH :Schedule-Item) ()
         "
Schedule-Item is an intermidate object to represent a one kernel in GPU.

```
f = cache_name or name
write_ids = f(*[storage_id_dst], *[dynamic_shape], *[inputs])
                      ^ can be modified by the memory-planner
```

It has a unique `name`, and `cache-name`. If `cache-name` was assigned, the compiler will fail to compile this schedule-item and reuse the kernel named `cache-name` instead.

In order to lowering the computation graph as the foreign language, `items` must be consisted of JITAble operations (except for special irs and :allocate). If it qualifies, `jitable` is set to T.

Otherwise, the scheduled items are relocated to the compiled avm directly. Specifially, if the item was :ALLOCATE, :allocated-p is set to T.

- blueprint[list] is a lowered schedule-item
- polyhedral[list] is a Polyhedral IR obtained by lowering blueprint
- auto-schedule-p[list] is set to T if it is worth to run auto-scheduler. (If there is a symbolic incremental, loop is not an affine and cannot run isl scheduler)
- items[list] are the scheduled items
- items-to-cache[list] are the copies of items but having the unique read/write. It is used to determine the equivalence of the two schedule-items.
- rank[fixnum] is the highest rank of the iteration space.
- storage-id-src[list] is the list of the storage-id of the source buffer (optimized by running memory-planner)
- storage-id-dst[list] is the list of the storage-id of the destination buffer (optimized by running memory-planner)
"
         :slots
         ((blueprint :type list :initform nil)
          (polyhedral)
          (jitable :type boolean)
          (allocate-p :type boolean)
          (auto-schedule-p :type boolean)
          (name :type symbol) (cache-name :type symbol)
          (items :type list) (items-to-cache :type list)
          (rank :type fixnum) (reduce-dims :type list)
          (read-types :type list) (write-types :type list)
          (reference-counters :type list)
          (storage-id-src :type list)
          (storage-id-dst :type list)
          (dynamic-shapes :type list)
          (rendered-object :type string)
          (compiled-object :type list)))

(defmethod print-node (node (id (eql :Schedule-Item)))
  (flet ((r (x y)
           (apply
            #'concatenate
            'string
            (butlast
             (loop for nth upfrom 0 below (max (length x) (length y))
                   for x1 = (nth nth x)
                   for y1 = (nth nth y)
                   if (or (eql x1 y1) (null y1))
                     append (list (format nil "~a" x1) ", ")
                   else
                     append (list (format nil "~a[~a]" x1 y1) ", "))))))
    (format nil "{ ~a } : [ ~a <- ~a where lowered-p=~a ~a]"
            (if (getattr node :allocate-p)
                "Allocate"
                (if (getattr node :jitable)
                    " KERNEL "
                    "  VMOP  "))
            (r (node-writes node) (getattr node :storage-id-dst))
            (if (getattr node :allocate-p)
                (subseq (node-reads (car (getattr node :items))) 0 (getattr (car (getattr node :items)) :nrank))
                (r (node-reads node) (getattr node :storage-id-src)))
            (if (getattr node :blueprint)
                "t" "nil")
            (if (getattr node :allocate-p)
                ""
                (if (getattr node :cache-name)
                    (format nil ":cache-name=~a :name=~a" (getattr node :cache-name) (getattr node :name))
                    (format nil ":name=~a" (getattr node :name)))))))
;; ~~ Scheduler ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defstruct Group
  (key (gensym) :type symbol)
  (reduce-dims nil :type list)
  (items nil :type list))

(defmethod verify-group ((group Group))
  (when (find :Allocate (group-items group) :key #'node-type)
    (assert (= (length (group-items group)) 1) () "Allocate should be scheduled standalone")))

(defun pname (name)
  (cl-ppcre:regex-replace-all
   "PAUSE/"
   (cl-ppcre:regex-replace-all "-" (cl-ppcre:regex-replace-all "GRAPH/" (princ-to-string name) "") "_")
   ""))

(defmethod make-unique-schedule-name ((group Group))
  (let ((names-func)
        (module-names)
        (seen))
    (dolist (item (group-items group))
      (if (and (typep (node-attr item) 'JITAble) (car (getattr item :_lowering_history))) ;; JITAble nodes have a lowering history
          (multiple-value-bind (name id) (values (caar (getattr item :_lowering_history)) (cdar (getattr item :_lowering_history)))
            ;; history = (module_name, module_id)
            (when (null (find id seen))
              (push id seen)
              (push (pname name) module-names)))
          (push (pname (node-type item)) names-func)))
    (let ((key
            (with-output-to-string (out)
              (princ "FUSED" out)
              (dolist (n (or module-names names-func))
                (format out "_~a" (ensure-string-as-compilable (princ-to-string n)))))))
      (when (> (length key) *function-name-maxlen*)
        (setf key (subseq key 0 *function-name-maxlen*)))
      (gensym key))))

(defun items-write-to (items graph)
  (let ((result (nodes-write-to items)) (wrap (map 'list #'node-id items)))
    (loop for item in items do
      (loop for write in (node-writes item)
            for users = (id->users graph write)
            if (some #'(lambda (x) (null (find (node-id x) wrap))) users) ;; user is read outside of the items
              do (push write result)))
    (remove-duplicates result)))

(defmethod group->schedule ((group Group) (base-graph Graph))
  (let ((reads (nodes-depends-on (group-items group)))
        (writes (items-write-to (group-items group) base-graph))
        (allocate-p (find :Allocate (group-items group) :key #'node-type))
        (no-symbolic-incremental-p t)
        (full-scalar-p t) (rank 0) (id2type (make-hash-table)))
    ;; Ensure there's no symbolic incremental for the auto scheduler.
    (dolist (node (group-items group))
      (loop for r in (append (node-reads node) (node-writes node))
            for rt in (append (relay-reads (read-type-relay node)) (relay-writes (read-type-relay node)))
            do (setf (gethash r id2type) rt)
            if rt do
              (when (> (buffer-nrank rt) 0)
                (setf full-scalar-p nil))
              (setf rank (max rank (buffer-nrank rt)))
              (dolist (v (buffer-views rt))
                (when (and v (third v) (symbolp (third v))) ;; v=(upfrom below by broadcast_p)
                  (setf no-symbolic-incremental-p nil)))))
    (make-node :GRAPH :Schedule-Item writes reads :name (make-unique-schedule-name group)
               :jitable (and (every #'jitable-p (group-items group)) (null full-scalar-p))
               :allocate-p (when allocate-p t)
               :auto-schedule-p (and no-symbolic-incremental-p (null full-scalar-p))
               :storage-id-dst writes
               :storage-id-src reads
               :read-types (map 'list #'(lambda (x) (gethash x id2type)) reads)
               :write-types (map 'list #'(lambda (x) (gethash x id2type)) writes)
               :reference-counters
               (map
                'list
                #'(lambda (x)
                    (+
                     (if (find x (graph-outputs base-graph)) 1 0)
                     (length (id->users base-graph x))))
                (append writes reads))
               :rank rank
               :reduce-dims (group-reduce-dims group)
               :items (group-items group)
               :items-to-cache (nodes-apply-static-gensym (map 'list #'copy-node (group-items group))))))

(defmethod merge-schedule-items ((si1 Node) (si2 Node) (base-graph Graph))
  (assert (eql (node-type si1) :Schedule-Item))
  (assert (eql (node-type si2) :Schedule-Item))
  (assert (= (getattr si1 :rank) (getattr si2 :rank)))
  (assert (or (null (getattr si1 :reduce-dims)) (null (getattr si2 :reduce-dims)) (equal (getattr si1 :reduce-dims) (getattr si2 :reduce-dims))))
  (group->schedule
   (make-group :items (append (getattr si1 :items) (getattr si2 :items))
               :reduce-dims (or (getattr si1 :reduce-dims) (getattr si2 :reduce-dims)))
   base-graph))

(defmethod group-get-type ((group Group))
  (let* ((last (nodes-write-to (group-items group)))
         (node (when last (find (car last) (group-items group) :key #'node-writes :test #'find))))
    (when node
      (car (relay-writes (read-type-relay node))))))

(defmethod jitable-p ((node Node))
  (and
   (null (find (node-type node) `(:ALLOCATE :PAUSE/BACKWARD)))
   (typep (node-attr node) 'JITAble)))

(defmethod node-reduce-axes ((node Node))
  (when (getattr node :reduction :allow-undefined t)
    (let ((write-buffer (car (relay-writes (read-type-relay node)))))
      (let ((out
              (loop for v in (buffer-views write-buffer)
                    for s in (buffer-shape write-buffer)
                    if (fourth v)
                      collect s
                    else
                      collect nil)))
        ;; Returns uncollapsed rank list
        (when (some #'identity out) out)))))

(defun buffer->view (buffer)
  (let* ((views (loop for shape in (buffer-shape buffer)
                      for nth upfrom 0
                      for view = (nth nth (buffer-views buffer))
                      if view collect view else collect (list 0 shape 1 nil)))
         (base (make-node :Buffer :View (list (gensym))
                         (append
                          (list (gensym))
                          (buffer-shape buffer)
                          (map 'list #'first views)
                          (map 'list #'second views)
                          (map 'list #'third views)
                          (buffer-stride buffer))
                          :permute (buffer-inferred-permute buffer)
                          :broadcast (map 'list #'fourth views)
                          :nrank (buffer-nrank buffer))))
    (when (getattr base :permute)
      (assert (= (length (buffer-inferred-permute buffer)) (buffer-nrank buffer))))
    base))

(defmethod group-items-st-rewriter ((group Group) f mask)
  (dolist (item (group-items group))
    (when (and mask (eql (node-type item) :INDEX-COMPONENTS)) ;; (cdr (node-reads index-components)) also represents for the stride
      (setf (node-reads item)
            (append
             (list (car (node-reads item)))
             (loop with s = (cdr (node-reads item))
                   for m in mask
                   if m collect 1 else collect (pop s)))))
    (loop for typ in (relay-reads (read-type-relay item))
          for view in (getattr item :_read_views)
          for nth upfrom 0
          unless (or (null typ) (= 0 (buffer-nrank typ)))
            do (multiple-value-bind (new-type new-view) (funcall f typ (car view))
                 (setf (nth nth (relay-reads (read-type-relay item))) new-type
                       (nth nth (getattr item :_read_views)) (list new-view))))
    (loop for typ in (relay-writes (read-type-relay item))
          for view = (buffer->view typ)
          for nth upfrom 0
          unless (or (null typ) (= 0 (buffer-nrank typ)))
            do (multiple-value-bind (new-type) (funcall f typ view)
                 (setf (nth nth (relay-writes (read-type-relay item))) new-type)))))

(defmethod group-rank ((group Group))
  (let ((buff (group-get-type group)))
    (when buff (buffer-nrank buff))))

(defmethod apply-index-component-fusion ((group Group) permute)
  "Permutes the strides of :INDEX-COMPONENTS in the group in the group"
  (dolist (item (group-items group))
    (when (and (eql (node-type item) :INDEX-COMPONENTS) (= (length permute) (length (cdr (node-reads item)))))
      (setf (cdr (node-reads item)) (permute-list permute (cdr (node-reads item)))))))

(defun broadcastable-p (prev new)
  (let ((prev-shape (copy-list (buffer-shape prev)))
        (new-shape  (copy-list (buffer-shape new))))
    (let ((p (loop for p in prev-shape if (not (eql p 1)) collect p))
          (n (loop for n in new-shape if (not (eql n 1)) collect n)))
      (equal p n))))

(defun buffer-mergeable-p (g b1 b2)
  (flet ((lazy-eq (a b)
           (or (eql a 1) (eql b 1) (eql a b)
               (and (symbolp a) (symbolp b) (expr-scalar-equivalent-p (expr-from-graph a g) (expr-from-graph b g))))))
    (every #'lazy-eq (buffer-shape b1) (buffer-shape b2))))

(defun buffer-complex-out-fusable-p (g b1 b2 mask)
  "An extra mergeable condition not to introduce an extra dim after reduction is performed.
g represents for Graph, b1 for the self buffer, b2 for the parent buffer, mask for the reduced dims."
  (declare (type Graph g) (type buffer b1 b2) (type list mask))
  (assert (= (buffer-nrank b1) (buffer-nrank b2)))
  (flet ((lazy-eq (a b nth m)
           ;; b = a buffer belongs to grouped schedule.
           ;; a = a buffer newly introducing.
           (let ((a-view (nth nth (buffer-views b1)))
                 (b-view (nth nth (buffer-views b2))))
             (if m
                 ;; Reduced dims ->
                 (flet ((ok (size view)
                          (or (eql size 1) (fourth view) (eql m 1))))
                   (and
                    (ok a a-view)
                    (ok b b-view)))
                 ;; Non-reduced dims -> mergeable as long as they have the same shape, or broadcasted.
                 (or (eql a 1) (eql b 1) (eql a b)
                     (and (symbolp a) (symbolp b) (expr-scalar-equivalent-p (expr-from-graph a g) (expr-from-graph b g))))))))
    (every #'lazy-eq (buffer-shape b1) (buffer-shape b2) (range 0 (buffer-nrank b1)) mask)))

(defun group-assert-rank (group r1 r2 view &aux (rank (max r1 r2)))
  (loop for item in (group-items group)
        do (loop for typ in (append (relay-reads (read-type-relay item)) (relay-writes (read-type-relay item)))
                 for nth upfrom 0
                 unless (or (null typ) (= 0 (buffer-nrank typ)))
                   do (assert (= rank (buffer-nrank typ)) ()
                              "Rank mismatch: (expected from ~a -> ~a)~%view=~a~%buffer:~%~a~%group~%~a"
                              (min r1 r2) rank view typ group))))

(defun group-view (group)
  (let* ((l (nodes-write-to (group-items group)))
         (node (when l (find (car l) (group-items group) :key #'node-writes :test #'find))))
    (when node
      (buffer->view (car (relay-writes (read-type-relay node)))))))

(defun merge-permute-from-mask (permute mask)
  (when (>= (length permute) (length mask))
    (return-from merge-permute-from-mask permute))
  (let ((val (uiop:symbol-call :caten/apis :compute-new-permute permute mask)))
    (assert (= (length val) (length mask)) () "permute=~a mask=~a val=~a" permute mask val)
    val))

(defun .view (view-old view-new &key (test #'eql))
  "Tries to compose two views and creates new one. If impossible, returns nil
test is used to compare two symbols or fixnums.
If the two view's rank are different, .view try to uprank the fewer rank view to the higher rank view."
  (declare (type (or null node) view-old)
           (type node view-new)
           (type function test))
  (when (null view-old) (return-from .view view-new))
  (assert (eql (node-type view-new) :VIEW))
  (assert (eql (node-type view-old) :VIEW))
  (labels ((teq (a b) (funcall test a b))
           (shape-eq (a b) (or (teq a 1) (teq b 1) (teq a b))))
    (cond
      ((= (the fixnum (getattr view-old :nrank)) (the fixnum (getattr view-new :nrank)))
       (let ((permute (getattr view-new :permute))
             (args    (cdr (node-reads view-old))) ;; exlucde first args
             (broadcast (getattr view-old :broadcast))
             (nrank   (getattr view-old :nrank)))
         (declare (type list args) (type fixnum nrank))
         (when permute
           ;; Sort the axis
           (setf args (loop for nth upfrom 0 below (length args) by nrank
                            for ls = (subseq args nth (+ nth nrank))
                            append (permute-list permute ls))
                 broadcast (permute-list permute broadcast)))
         (let* ((sizes  (subseq args 0 nrank))
                (below  (subseq args nrank (* 2 nrank)))
                (to     (subseq args (* 2 nrank) (* 3 nrank)))
                (by     (subseq args (* 3 nrank) (* 4 nrank)))
                (stride (subseq args (* 4 nrank) (* 5 nrank)))
                (new-broadcast (map 'list #'(lambda (x y) (or x y)) broadcast (getattr view-new :broadcast)))
                (contiguous-p ;; = no offsets are created
                  (and
                   (every #'(lambda (x) (teq x 0)) below)
                   (every #'teq to sizes)
                   (every #'(lambda (x) (teq x 1)) by))))
           (if (and contiguous-p (every #'shape-eq sizes (subseq (node-reads view-new) 1 (1+ (getattr view-new :nrank)))))
               (let ((node (copy-node view-new)))
                 (setf (getattr node :broadcast)
                       (loop for s-old in (subseq args 0 nrank)
                             for s-new in (subseq (node-reads view-new) 1 (1+ (getattr view-new :nrank)))
                             for b in new-broadcast
                             if (and (teq s-old 1) (not (eq s-new 1)))
                               collect t
                             else
                               collect b))
                 (loop for s in stride
                       for nth upfrom (1+ (* 4 nrank))
                       do (setf (nth nth (node-reads node)) s))
                 node)
               (progn
                 ;; hutuuni new view wo sakusei dekiru
                 (warn "need some update")
                 nil))))) ;; [TODO] Create VIEW.Pad and merge them. (renderer will render then using where)
      (T
       (flet ((make-mask (node)
                (loop for s in (subseq (node-reads node) 1 (1+ (getattr node :nrank)))
                      for b in (getattr node :broadcast)
                      if (teq s 1) collect t else collect b))
              (padding-with-mask (mask pad-value list)
                (if (>= (length list) (length mask))
                    list
                    (progn
                      (assert (= (length list) (count-if #'null mask)) () "padding-with-mask: list and mask should have the same length. mask = ~a list = ~a" mask list)
                      (loop for m in mask
                            for nth upfrom 0
                            if m collect (if (listp pad-value) (nth nth pad-value) pad-value)
                              else collect (pop list))))))
         (let ((m1 (make-mask view-old))
               (m2 (make-mask view-new)))
           (if (> (length m1) (length m2)) ;; hide the smaller one
               (setf m2 (loop repeat (length m2) collect nil))
               (setf m1 (loop repeat (length m1) collect nil)))
           (when (and (every #'null m1) (every #'null m2)) (return-from .view nil))
           (when (not (= (+ (count-if #'identity m1) (getattr view-new :nrank))
                         (+ (count-if #'identity m2) (getattr view-old :nrank))))
             (return-from .view nil))
           (let ((view-old (copy-node view-old))
                 (view-new (copy-node view-new)))
             (flet ((merge-mask (node mask other-size &aux (nrank (getattr node :nrank)) (args (node-reads node)))
                      (append
                       (list (car (node-reads node)))
                       (padding-with-mask mask other-size (subseq args 1 (1+ nrank))) ;; args
                       (padding-with-mask mask 0 (subseq args (1+ nrank) (1+ (* 2 nrank)))) ;; below
                       (padding-with-mask mask other-size (subseq args (1+ (* 2 nrank)) (1+ (* 3 nrank)))) ;; to
                       (padding-with-mask mask 1 (subseq args (1+ (* 3 nrank)) (1+ (* 4 nrank)))) ;; by
                       (padding-with-mask mask 1 (subseq args (1+ (* 4 nrank)) (1+ (* 5 nrank))))))) ;; stride
               (setf (node-reads view-old) (merge-mask view-old m2 (subseq (cdr (node-reads view-new)) 0 (getattr view-new :nrank)))
                     (node-reads view-new) (merge-mask view-new m1 (subseq (cdr (node-reads view-old)) 0 (getattr view-old :nrank)))
                     (getattr view-old :broadcast) (padding-with-mask m2 t (getattr view-old :broadcast))
                     (getattr view-new :broadcast) (padding-with-mask m1 t (getattr view-new :broadcast)))
               (when (getattr view-old :permute)
                 (setf (getattr view-old :permute) (merge-permute-from-mask (getattr view-old :permute) m2)))
               (when (getattr view-new :permute)
                 (setf (getattr view-new :permute) (merge-permute-from-mask (getattr view-new :permute) m1)))
               (let ((nrank (max (getattr view-new :nrank) (getattr view-old :nrank))))
                 (setf (getattr view-old :nrank) nrank
                       (getattr view-new :nrank) nrank)
                 (assert (= (length (node-reads view-old)) (length (node-reads view-new))))
                 (.view view-old view-new :test test))))))))))

(defun sync-views-and-buffer (view base-buffer)
  (declare (type node view))
  (assert (eql (node-type view) :VIEW))
  (let ((nrank (getattr view :nrank))
        (args (cdr (node-reads view))))
    (multiple-value-bind (sizes below to by stride)
        (values
         (subseq args 0 nrank)
         (subseq args nrank (* 2 nrank))
         (subseq args (* 2 nrank) (* 3 nrank))
         (subseq args (* 3 nrank) (* 4 nrank))
         (subseq args (* 4 nrank) (* 5 nrank)))
      (setf (buffer-shape base-buffer)
            sizes
            (buffer-views base-buffer)
            (loop for b1 in below
                  for t1 in to
                  for b2 in by
                  for b3 in (getattr view :broadcast)
                  collect (list b1 t1 b2 b3))
            (buffer-stride base-buffer)
            stride
            (buffer-nrank base-buffer) (getattr view :nrank)
            (buffer-inferred-permute base-buffer) (getattr view :permute))
      base-buffer)))

(defun group-view-rewritable-p (parent read-view)
  "
Self and parent are connected by the following relations.
```
 [Parent Group Items ...]
           |
       [read_view]
           |
        [SELF]
```
Self reads the elements of parent using `read_view`.
If self and parent satisfies the following equation, this function returns T indicating that self and parent are mergeable.
mergeable = all views in parent group can be composed with read_view.
"
  (declare (type Group parent) (type (or null node) read-view))
  (when (null read-view) (return-from group-view-rewritable-p t))
  (labels ((view-mergeable-p (views &aux (view (car views)))
             (assert (<= (length views) 1))
             (if view
                 (.view view read-view)
                 t))
           (mergeable-p (node)
             (every #'view-mergeable-p (getattr node :_read_views))))
    ;; Only compare the outputs
    (let* ((items (nodes-write-to (group-items parent)))
           (items (loop for item in (group-items parent)
                        if (find (car (node-writes item)) items)
                          collect item)))
    (every #'identity (map 'list #'mergeable-p items)))))

(defun group-compose-views (parent read-view mask)
  (group-items-st-rewriter
   parent
   #'(lambda (old-buffer old-view)
       (let ((new-view (.view old-view read-view)))
         (assert new-view () "The group and read-view is not mergeable.")
         (let ((new-buffer (copy-buffer old-buffer)))
           (sync-views-and-buffer new-view new-buffer)
           new-buffer)))
   mask))

(defun group-merge-p (self graph node parent-group nth)
  (declare (type group self) (type graph graph) (type node node) (type group parent-group)
           (type fixnum nth)
           (optimize (speed 3)))
  (symbol-macrolet ((->ok
                      (progn
                        (setf (group-reduce-dims self) (or (group-reduce-dims self) (group-reduce-dims parent-group)))
                        (return-from group-merge-p t)))
                    (->ng (return-from group-merge-p nil)))
    (when (and (group-reduce-dims self) (group-reduce-dims parent-group))
      ;; Both groups are reduced?
      (when (not (equal (group-reduce-dims self) (group-reduce-dims parent-group)))
        ;; Reduced at the same rank?
        ->ng))
    (let* ((read (nth nth (node-reads node)))
           (read-node (id->value graph read))
           (read-view (car (nth nth (getattr node :_read_views))))
           (read-type (nth nth (relay-reads (read-type-relay read-node))))
           (self-type (group-get-type self)))
      (assert (<= (length (the list (nth nth (getattr node :_read_views)))) 1))
      ;; Relations between group and parent-group:
      ;; ```
      ;; group=parent | X[write_type]{write_iter} = f(...)
      ;; group=self   | ... = f(..., X[read_type]{read_iter})
      ;; ```
      (when (or (not (jitable-p node)) (not (jitable-p read-node)))->ng)
      ;; ~~ merge views ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ;; :shrink is not mergeable
      ;;(when (and read-view (eql (identify-view-type read-view) :shrink))
      ;; [TODO] Add a mask like:
      ;; _gid0 >= 2 && _gid1 >= 2 ? move1 : move2
      ;;  ->ng)
      (let ((r1 (group-rank self))
            (r2 (group-rank parent-group)))
        (declare (type fixnum r1 r2))
        ;; Scalars are always merged
        (when (or (= r1 0) (= r2 0))->ok)
        (when (= r1 r2)
          (when (group-reduce-dims parent-group)
            ;; e.g.:
            ;;   [Matmul]
            ;;      |
            ;;    [GeLU]
            ;;      |
            ;;   [Matmul] < group-reduce-dims matches but need to introduce a new loop...
            ;;      | 
            ;; Complex-Out-Fusable: After the reduction is performed in the parent group, only the buffers which does not introduce new axis, are allowed to be merged.
            ;; does not introduce new axis = the total element size is the same as the reducing parent group.
            (if (buffer-complex-out-fusable-p graph (group-get-type self) (group-get-type parent-group) (group-reduce-dims parent-group))
                nil
                ->ng)))
        (when (buffer-mergeable-p graph (group-get-type self) (group-get-type parent-group))
          (let* ((rewrite-self (< r1 r2))
                 (mask
                   (if (broadcastable-p read-type self-type)
                       (map 'list #'(lambda (x) (eql x 1)) (buffer-shape (if rewrite-self self-type read-type)))
                       (map 'list #'fourth (buffer-views (if rewrite-self self-type read-type))))))
            (when rewrite-self
              (when (null read-view)
                (setf read-view (group-view parent-group)))
              (assert read-view () "squeezing the array without expliciting %view is not allowed."))
            (when read-view
              (if rewrite-self
                  (let ((new-view (.view (group-view parent-group) read-view)))
                    (assert (= (the fixnum (getattr new-view :nrank)) (max r1 r2)))
                    (group-compose-views self new-view mask)
                    ->ok)
                  (group-compose-views parent-group read-view mask)))
            (when (and read-view (getattr read-view :permute))
              (apply-index-component-fusion parent-group (getattr read-view :permute)))
            (group-assert-rank self r1 r2 read-view)
            (group-assert-rank parent-group r1 r2 read-view)
            ->ok))
        ->ng))))

(defmethod merge-groups ((self Group) parents mergeable-list)
  (let* ((p (loop for m in mergeable-list for p in parents
                  if m collect p))
         (ranks (map 'list #'group-rank p))
         (srank  (group-rank self)))
    (loop for r in ranks
          for group in p
          for eql-p = (or (eql 0 r) (eql 0 srank) (= r srank))
          unless eql-p do
            (assert (< r srank) () "(< r=~a srank=~a)" ranks srank)
            (let* ((typ1 (group-get-type self))
                   (m (map 'list #'fourth (buffer-views typ1))))
              (assert (some #'identity m))
              (group-compose-views group (group-view self) m)
              (group-assert-rank group srank srank nil))))
  (loop for m in mergeable-list
        for p in parents
        if m do
          (assert (or (null (group-reduce-dims p)) (null (group-reduce-dims self)) (equal (group-reduce-dims self) (group-reduce-dims p)))
                  ()
                  "Reduce dims = ~a ~a" (group-reduce-dims p) (group-reduce-dims self))
          (setf (group-items self) (append (group-items p) (group-items self))
                (group-reduce-dims self) (or (group-reduce-dims self) (group-reduce-dims p))))
  self)
;; depth first serach
(defun recursive-create-groups (id graph &key (seen))
  (declare (type symbol id) (type graph graph) (type hash-table seen) (optimize (speed 3)))
  (when (gethash id seen) (return-from recursive-create-groups))
  (setf (gethash id seen) t)
  (let* ((node (id->value graph id))
         (self
           (make-group
            :items (list node)
            :reduce-dims (node-reduce-axes node)))
         (parents
           (reverse (map 'list #'(lambda (x) (and (symbolp x) (recursive-create-groups x graph :seen seen))) (reverse (node-reads node))))))
    (declare (type node node) (type list parents))
    ;; Consider this structured graph:
    ;; parents[0] parents[1] parents[2] ...
    ;;        \      |      /
    ;;              self
    ;;               |
    ;; => The function returns this flattend list
    ;; (list               (list
    ;;   parents[0]          parent[2]
    ;;   parents[1]            ...
    ;;   parents[2]    =>    group(items=self+parent[0]+parent[1]))
    ;;     ...
    ;;   self)
    ;;  (No fuse)        (When parent[0] and parent[1] are fusable)
    (let ((mergeable-p-list
            (loop for parent in parents
                  for parent-return = (car parent)
                  for nth fixnum upfrom 0
                  if parent-return
                    collect (group-merge-p self graph node parent-return nth)
                  else
                   collect nil)))
      (assert (= (length mergeable-p-list) (length parents)))
      (nconc
       (list (merge-groups self (map 'list #'car parents) mergeable-p-list))
       (loop for p in parents
             for m in mergeable-p-list
             if m ;; mergeable
               append (cdr p)
             else ;; unmergeable
             append p)))))
;; ~~~~~~ More Fusion Rules ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;; [TODO] Rewrite them as a pattern matcher.
(defun make-can-split-p (schedule-graph)
  (declare (optimize (speed 3))
           (type fastgraph schedule-graph))
  (let ((in-degrees (make-hash-table)) (out-degrees (make-hash-table)))
    (declare (type hash-table in-degrees out-degrees))
    (flet ((butseen (list)
             (loop for l in list
                   for v = (id->value schedule-graph l)
                   if (and v (symbolp l)) collect v)))
      (loop for node in (graph-nodes schedule-graph) do
        (setf (gethash (node-id node) in-degrees) (butseen (node-reads node)))
        (dolist (r (gethash (node-id node) in-degrees))
          (when (null (find (node-id node) (the list (gethash (node-id r) out-degrees)) :key #'node-id))
            (push node (gethash (node-id r) out-degrees))))))
    (flet ((node->users (node)
             (let ((users (gethash (node-id node) out-degrees)))
               (every #'(lambda (x) (getattr x :jitable)) users))))
      #'node->users)))

(defun apply-schedule-item-fusor (f can-split-p schedule-graph base-graph &aux (seen) (changed-p t))
  (declare (optimize (speed 3))
           (type function f can-split-p)
           (type fastgraph schedule-graph)
           (type graph base-graph)
           (type list seen))
  (labels ((parent-groups (self)
             (assert (node-p self))
             (loop for r in (node-reads self)
                   for val = (and (symbolp r) (id->value schedule-graph r))
                   ;; Only :jitable scheduleitems are merged
                   if val collect val))
           (explore (id)
             (let* ((self (id->value schedule-graph id))
                    (_ (when (or (null self) (find (node-id self) seen)) (return-from explore)))
                    (candidates (parent-groups self))
                    (self-mergeable-p (getattr self :jitable)))
               (declare (ignore _))
               (push (node-id self) seen)
               (loop for parent in candidates
                     if (and self-mergeable-p parent
                             (getattr parent :jitable)
                             (funcall can-split-p parent) ;; confirm that the parent is not used by special ops
                             (or (null (getattr self :reduce-dims)) (null (getattr parent :reduce-dims))
                                 (equal (getattr self :reduce-dims) (getattr parent :reduce-dims)))
                             (funcall f self parent))
                       do (let ((merged (merge-schedule-items self parent base-graph)))
                            (setf changed-p t)
                            (insert-nodes schedule-graph (list merged))
                            (dolist (w (node-writes parent))
                              (remnode schedule-graph w))))
               (mapc #'explore (node-reads self)))))
    ;; This loop finishes in the constant time.
    (loop while changed-p do
      (setf changed-p nil seen nil)
      (mapc #'explore (graph-outputs schedule-graph)))))
      
(defun apply-reduce+move-fusion (schedule-graph can-split-p base-graph)
  "Applies the post-loop-fusion to eliminate MOVE after the reduction.
```
     Group1
       |
      SELF
```
Consider the case where group1 and self fusion was rejected by the group-reduce-dims rule, group1 is a reduction, and `MOVE` after the reduction is merged to `self`. For example:
```
[Group1]
{
  int _acc_0 = 0;
  for (...)
    _acc_0 += ...;
  // Expected element wise operation here! otherwise we have to mutate _acc_0 as an array...
}
[SELF]
{
  for (...)
   out[...] = f(_acc_0);
}
```
This function enumerates all such pairs and allows all reduction operations to have a `MOVE` node after the reduction by serializing the loop. (This scheduling pattern can be observed by running an operation with multiple reductions in a single kernel, such as `!argmax`, or `RMSNorm`, etc.)

To put it bluntly, this function explores all `reduced-but-not-stored` pairs, and merges two schedule items who shares `reduced-but-not-stored`.

If this interrupts the parallelism, AutoScheduler should distribute them and create a shared buffer."
  (declare (type FastGraph schedule-graph))
  (flet ((reduce-w/o-store (self)
           (loop for id in (node-writes self) ;; only the output of the kernel matters
                 for item = (find id (getattr self :items) :key #'node-writes :test #'find)
                 if (getattr item :reduction :allow-undefined t)
                   collect item)))
    (apply-schedule-item-fusor
     #'(lambda (self parent) (declare (ignore self)) (reduce-w/o-store parent))
     can-split-p
     schedule-graph
     base-graph)))

(defun apply-serialize-reduction (schedule-graph can-split-p base-graph)
  (flet ((is-tensor (buffer)
           (not (every #'(lambda (x) (eql x 1)) (buffer-shape buffer))))
         (depend-dims-p (items rank &aux (common-views (make-list rank)))
           (loop for item in items do
             (loop for rt in (relay-reads (read-type-relay item))
                   if (some #'identity (buffer-views rt)) do
                     (loop for nth upfrom 0
                           for view in (buffer-views rt) do
                             (setf (nth nth common-views) (or (nth nth common-views) (fourth view))))))
           (and (every #'null (butlast common-views))))
         (no-index-components-p (si)
           (null (find :INDEX-COMPONENTS (getattr si :items) :key #'node-type))))
    (apply-schedule-item-fusor
     #'(lambda (self parent)
         (let ((self-type (group-get-type (make-group :items (getattr self :items))))
               (parent-type (group-get-type (make-group :items (getattr parent :items)))))
           (and
            (no-index-components-p self) ;; [TODO] Merge Index Components
            (no-index-components-p parent)
            (= (getattr self :rank) (getattr parent :rank)) ;; Make sure not extra loop is introduced
            (buffer-mergeable-p base-graph self-type parent-type)
            (is-tensor self-type) (is-tensor parent-type)
            (or
             (null (getattr self :reduce-dims))
             (null (getattr parent :reduce-dims))
             (and
              (equal (getattr self :reduce-dims) (getattr parent :reduce-dims))
              (depend-dims-p (getattr self :items) (getattr self :rank))
              (depend-dims-p (getattr self :items) (getattr parent :rank)))))))
     can-split-p
     schedule-graph
     base-graph)))

(defun apply-move-after-reduction (schedule-graph)
  (declare (type graph schedule-graph) (optimize (speed 3)))
  (labels ((%newtype (buffer)
             (caten/avm:make-buffer
              (buffer-nrank buffer)
              (loop for s in (buffer-shape buffer)
                    for nth fixnum upfrom 0
                    for v = (nth nth (buffer-views buffer))
                    if (and (listp v) (fourth v)) ;; broadcasted
                      collect 1
                    else
                      collect s)
              (buffer-stride buffer)
              (buffer-dtype buffer)
              (loop for s in (buffer-shape buffer)
                    for nth fixnum upfrom 0
                    for v = (nth nth (buffer-views buffer))
                    if (and (listp v) (fourth v))
                      collect `(0 1 1 t)
                    else
                      collect v)))
           (%jstore (w a b base-type)
             (make-node :Buffer :MOVE (list w) (list a b)
                        :_type_relay
                        (caten/codegen/shape-inference:make-inferred-type
                         (list (%newtype base-type) (%newtype base-type))
                         (list (%newtype base-type)))))
           (acc (id) (intern (format nil "~(~a~)_acc" id)))
           (r (si &aux (g (apply #'make-graph (getattr si :items))))
             (dolist (node (graph-nodes g))
               ;; reduced but no users in the group: This is now allowed. Adding :MOVE
               (when (and (getattr node :reduction :allow-undefined t)
                          (null (id->users g (car (node-writes node))))) ;; no users in a group
                 (let ((base-id (car (node-reads node)))
                       (write-id (car (node-writes node)))
                       (acc-id (acc (car (node-reads node)))))
                   (setf (node-writes node) (list acc-id))
                   ;; val_3 = val_3_acc
                   ;; ```
                   ;; float val_3 = 0.0;               float val_3 = 0.0;
                   ;; for (...) val_4 = val_3+1.0  =>  for (...) val_3_acc = val_3+1.0;
                   ;; ```                              val_4[0] = val_3_acc;
                   (push
                    (%jstore write-id base-id acc-id (car (relay-writes (read-type-relay node))))
                    (getattr si :items)))))))
    (mapc #'r (graph-nodes schedule-graph))))
;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defgeneric graph-schedule (graph) (:documentation "Splits a given graph into small subgraphs called Schedule-Item. It always returns `FastGraph`."))

(defmethod graph-schedule ((graph Graph))
  (let* ((seen (make-hash-table))
         (groups (apply #'append (map 'list #'(lambda (x) (recursive-create-groups x graph :seen seen)) (graph-outputs graph)))))
    (mapc #'verify-group groups)
    (when (>= (ctx:getenv :JIT_DEBUG) 4)
      (format t "[graph-schedule] Prescheduled ~a groups:~%" (length groups))
      (dolist (g groups)
        (when (not (eql (node-type (car (group-items g))) :Allocate))
          (print g)))
      (fresh-line))
    (let ((schedule (apply #'make-graph (map 'list #'(lambda (x) (group->schedule x graph)) groups))))
      (setf (graph-outputs schedule) (graph-outputs graph))
      (setf schedule (->fast-graph schedule))
      ;; ~~ Rewriting Rules + Post Fusion ~~~~~~~~~~~~~~~~~~~~~~
      (let ((can-split-p-cache (make-can-split-p schedule))) ;; Create a hash table for recording the edge and reference counter.
        (apply-reduce+move-fusion schedule can-split-p-cache graph)
        (apply-serialize-reduction schedule can-split-p-cache graph)) ;; (TODO: Only execute when MAXIMIZE_MEMORY_LOCALITY=1?)
      (apply-move-after-reduction schedule)
      ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      (when (>= (ctx:getenv :JIT_DEBUG) 3)
        (format t "[graph-schedule] Schedule Graph:~%~a~%" schedule))
      schedule)))
