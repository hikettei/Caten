(in-package :caten/workflow)

;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;; Goal: Export the entire code (including tokenizer, data loader, matrix computation kernel) for any language
;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;; caten/workflow
;; - Includes a wrapper for `caten`.
;; - Includes a class for Tokenizer.
;; - Each workflow can be compiled into C, or any language, using caten/ajit renderer (comptible with them).

;; Workflow and Concepts
;; - Implement Export2C Mode
;; - Implement Control, High-Level Interface, Including Function defining, IF/FOR
;;   - DSL

;; [TODO]
;; - ここでこのモデル全体をCommon Lispで読み込むことによって，モデルのコンパイル結果をCache可能にする
;; - 若しくは，C言語/Python/Smaller Common LispへCompileして実行を可能に

;; Backend has two facets:
;; - Kernel Renderer   [ Low-Level  ]
;; - Workflow Renderer [ High-Level ]

;; TODO: Compile the entire graph. Including token sampling
;;      Input
;;        |
;; [Action: Tokenizer]
;;        |
;;  |-[Action:Run]-|
;;  | Transformer  | <-------------------------------|
;;  |--------------|                                 |
;;        |                                          | x N
;;        |----[Action: Logits Argmax Concatenate] --|
;;        |    
;;    [Output]
;;        |

;; Action:
;; - Is a CLOS class
;; - Only initialized in defworkflow macro
;; - Workflow is a aIR graph

(eval-when (:compile-toplevel :load-toplevel :execute)

(defclass Action ()
  ((device :type caten/ajit:device :initarg :device :reader action-device)
   (ctx :type Context :accessor action-ctx)))

(defun run-action (device action-name &rest args)
  (declare (type caten/ajit:device device)
           (type symbol action-name))
  (let ((action (make-instance action-name :device device)))
    (ctx-compile (action-ctx action) device)
    (flet ((->args (arg)
             (if (tensor-p arg)
                 (tensor-buffer arg)
                 arg)))
      (let ((shape-args (apply #'infer-shape action args)))
        (apply #'values (apply #'ctx-run (action-ctx action) (map 'list #'->args (append args shape-args))))))))

(defun parse-type-designator (type-form var)
  "Return (values pointer-p dtype stride shape additional-computation-form)"
  (match type-form
    ((guard x (keywordp x))
     (values nil x))
    ((list (guard x (eql x :pointer)) y)
     (values t y))
    ((list (eql :tensor) order (list* size) element-dtype)
     (assert (member order '(:row :column)) () "defaction: ORDER should be either :row or :column")
     (multiple-value-bind (strides stride-compute-forms) (calc-strides-with-form order size)
       (values t element-dtype strides size stride-compute-forms size)))
    (_
     (error "defaction: Cannot infer the type of ~A.~%Provide (declare (type type_name variable ...)) form to declare the type." var))))

;; Each action can be compiled into Render-Graph first, and then each language
(defun action-parse-lambda-list-and-body (args body &aux (additional-forms) (shape-table (make-hash-table)))
  (multiple-value-bind (remaining-form declare docstring) (alexandria:parse-body body :documentation t)
    (multiple-value-bind (params optional rest kw allow-other-keys-p aux key-p)
        (alexandria:parse-ordinary-lambda-list args :normalize nil)
      (declare (ignore key-p))
      (assert (null allow-other-keys-p) () "defaction: &allow-other-keys is not supported")
      (let ((variables
              (nconc
               params
               (map 'list #'car optional)
               (when rest (list rest))
               (map 'list #'car kw)
               (map 'list #'car aux)))
            (type-decl
              (loop for decl in declare
                    append
                    (loop for form in decl
                          when (and (listp form) (equalp (symbol-name (car form)) "TYPE"))
                            collect form)))
            (shape-args))
        (values
         (append
          (loop for var in variables
                for type-form = (find var type-decl :key #'cddr :test #'find)
                collect
                (multiple-value-bind (is-pointer dtype strides size additional-compute-form declared-shape)
                    (parse-type-designator (second type-form) var)
                  (assert (= (length strides) (length size)))
                  (when (> (length size) 0)
                    (setf (gethash var shape-table) declared-shape))
                  (when additional-compute-form
                    ;; Additional (autogenerated) forms for computing strides
                    (dolist (f additional-compute-form)
                      (push f additional-forms)))
                  (let ((dtype (caten/common.dtype:dtype-alias dtype)))
                    (caten/ajit:make-argument
                     :name var
                     :pointer-p is-pointer
                     :dtype dtype
                     :type :user :io :input
                     :metadata (caten/avm:make-buffer (length size) size strides dtype nil)))))
          (let ((symbols
                  (remove-duplicates
                   (loop for value in (alexandria:hash-table-values shape-table)
                         append
                         (loop for v in value if (symbolp v) collect v)))))
            (setf shape-args
                  (loop with dtype = :int64
                        for s in symbols
                        collect
                        (caten/ajit:make-argument :name s :pointer-p nil :dtype dtype :type :user :metadata (caten/avm:make-buffer 0 nil nil dtype nil))))
            shape-args))
         `(,@(reverse additional-forms) ,@remaining-form)
         docstring
         shape-args shape-table
         (let ((optimize-form (find "OPTIMIZE" (cdr (car declare)) :key (alexandria:compose #'symbol-name #'car) :test #'equalp)))
           (second (find "DEBUG" (cdr optimize-form) :key (alexandria:compose #'symbol-name #'car) :test #'equalp))))))))

(defun cname (symbol) (intern (cl-ppcre:regex-replace-all "-" (symbol-name symbol) "_")))

(defmacro defaction (name lambda-list &body body)
  "
```
(defaction name lambda-list &body body)
```

Define an action.

- name[symbol]: The name of the action.
- lambda-list[list]: lambda-list
- body[list]: The body of the action. (Lisp-Like DSL, see caten/lang)

Dtype decl:
```
- (:pointer :dtype)
- :dtype
- (:tensor ORDER (SIZE) :dtype) (e.g.: `(:tensor :row (M N) :int)), note that M and N should be provided as a variable first!
```

```
(optimize (debug 3))
              ^ debug here corresponds to JIT_DEBUG. JIT_DEBUG=1 to see the compiled code.
```
"
  ;; Args: (Name, Type)
  (multiple-value-bind (args1 body1 docstring1 shape-args1 shape-table1 debug) (action-parse-lambda-list-and-body lambda-list body)
    ;; C-c C-c and the error check
    (let ((ctx (make-context-from-list (cname name) args1 body1))
          (ctx-bind (gensym "CTX"))
          (debug (or debug 0))
          (dev (caten/ajit:default-device :clang))) ;; [FIX] Is the device always clang
      (when (>= debug 1)
        (ctx:with-contextvar (:jit_debug debug)
          (ctx-compile ctx dev)))
      `(progn
         (defclass ,name (Action)
           nil
           (:documentation ,(or docstring1 "")))
         (a/defun ,name (,ctx-bind ,@(if shape-args1
                                         ;; [TODO] Use &key for functions whose argument have a tensor.
                                         (append
                                          lambda-list
                                          `(&key ,@(map 'list #'caten/ajit:argument-name shape-args1)))       
                                         lambda-list))
                  ,(or docstring1 "")
           (let ((forms (loop for arg in (list ,@(map 'list #'caten/ajit:argument-name args1))
                              collect (multiple-value-list (stash-forms ,ctx-bind arg (gensym "_FCALL") t))))
                 (output-place-list
                   (loop for x in (list ,@(map 'list #'caten/ajit:argument-name args1))
                         collect (gensym "_OUTPUT_PLACEHOLDER"))))
             (declare (ignorable output-place-list))
             (ctx-add-dependency ,ctx-bind (action-ctx (make-instance ',name)))
             (make-parsed-form
              (append
               (apply #'append (map 'list #'car forms))
               (list
                ,@(loop for output in (ctx-outputs ctx)
                        for nth upfrom 0
                        collect
                        `(ctx-declare-local-var ,ctx-bind (nth ,nth output-place-list) ,(caten/ajit:argument-dtype output)))
                (ctx-make-funcall
                 ,ctx-bind ',(cname name)
                 (append
                  (map 'list #'second forms)
                  (map 'list #'(lambda (x) (caten/ajit:make-expr :address-of (caten/ajit:make-expr :const x))) output-place-list)))))
              ,(if (ctx-outputs ctx)
                   `(caten/ajit:make-expr :Const (car output-place-list))
                   `(caten/ajit:make-expr :Const nil))
              ,(if (ctx-outputs ctx)
                   `(make-const-buffer ,(caten/ajit:argument-dtype (car (ctx-outputs ctx))))
                   `(make-const-buffer :bool)))))
         (defmethod infer-shape ((self ,name) &rest args)
           (declare (ignorable args))
           (let ((tensors (make-hash-table))
                 (result (make-hash-table)))
             (declare (ignorable tensors result))
             ,@(loop for p in (map 'list #'caten/ajit:argument-pointer-p args1)
                     for place in (map 'list #'caten/ajit:argument-name args1)
                     for nth upfrom 0
                     for arg = `(nth ,nth args)
                     if p
                       collect
                     `(progn
                        (assert (tensor-p ,arg) () "run-action: ~ath argument ~a should be a tensor." ,nth ,arg)
                        (setf (gethash ',place tensors) ,arg)))
             ,@(loop for place in (alexandria:hash-table-keys shape-table1)
                     for shape = (gethash place shape-table1)
                     collect
                     `(assert (= (caten/avm:buffer-nrank (tensor-buffer (gethash ',place tensors))) ,(length shape))
                              ()
                              "run-action: Inconsistent rank for ~a, it should be ~a tensor." ',place ',shape)
                     append
                     (loop for s in shape
                           for nth upfrom 0
                           if (symbolp s)
                             collect
                           `(let ((val (nth ,nth (caten/avm:buffer-shape (tensor-buffer (gethash ',place tensors))))))
                              (when (gethash ',s result)
                                (assert (eql val (gethash ',s result)) () "infer-shape: Inconsistent shape for ~a" ',s))
                              (assert (numberp val) () "infer-shape: Shape should be a number for ~a" (gethash ',place tensors))
                              (setf (gethash ',s result) val))))
             (list
              ,@(loop for key in (map 'list #'caten/ajit:argument-name shape-args1)
                      collect `(or (gethash ',key result) (error "infer-shape: Cannot infer the shape of ~a" ',key))))))
         (defmethod initialize-instance :after ((self ,name) &rest initargs)
           (declare (ignore initargs))
           (multiple-value-bind (args body) (action-parse-lambda-list-and-body ',lambda-list ',body)
             (setf (action-ctx self) (make-context-from-list ',(cname name) args body))))))))
) ;; eval-when

(defaction compare-string (a b)
  (declare (type (:tensor :row (-1) :char) a b)
           (optimize (debug 1)))
  (_%while (and a (= a b))
           (progn
             (setf a (+ a 1))
             (setf b (+ b 1))))
  (= 0 (- a b)))

(defaction SentencePiece (text vocabulary scores)
  (declare (type (:tensor :row (len) :char) text)
           (type (:tensor :row (n)   :string) vocabulary)
           (type (:tensor :row (n)   :float32) scores)
           (optimize (debug 1)))
  0)

(defaction SentencePiece (text)
  (declare (type (:tensor :row (10) :uint8) text)
           (optimize (debug 1)))

  )

(defaction Fib (n)
  (declare (type :int64 n)
           (optimize (debug 1)))
  n)

;; - [x] Recursive Call (Implement Fib)
;; - [x] Call Action From Action
;; - [ ] Separate NameSpace (keep using string will 100% cause naming confliction)
;; - [x] Involve the related function in the compilation.
;; - [x] Load From Tensor Mode
;;  - [x] Auto Size Infer
;;  - [ ] Tokenizerは一旦Lisp実装にする方針で...
;;  - [ ] Tokenizerについては一旦忘れます
;;  - [ ] Module CompileのじどうCache,条件分岐(ControlFlow)など，

#|
(defaction Simple-Tokenizer (text vocabulary n vocab_size)
  (declare (type (:array :row (n) :char) text)
           (type (:array :row (vocab_size) :char) vocabulary)
           (type :int64 n vocab_size)
           (optimize (debug 1)))
  (map :int64 (lambda (c) (position c vocabulary)) text))

(defaction Fib (n)
  (declare (type :int64 n)
           (optimize (debug 1)))
  n)

(defaction Fib1 (n)
  (declare (type :int64 n) (optimize (debug 3)))
  (Fib n))

(defaction str-lookup (word )
  (declare (type :char word))
  )

(defstruct Dictionary
  (word-pool )          ;; flattened word arary
  (position->offset)    ;; idx -> offset in word-pool
  (position->word-len)  ;; idx -> word length
  (position->score))     ;; idx -> score in word-pool

(defun make-dict-from-vocab (vocabulary scores)
  (declare (type array vocabulary scores))
  (let* ((n-vocab (array-total-size vocabulary))
         (word-pool (apply #'concatenate 'string (coerce vocabulary 'list)))
         (position->word-pos (make-array n-vocab :element-type '(unsigned-byte 32) :initial-element 0))
         (position->word-len (make-array n-vocab :element-type '(unsigned-byte 32) :initial-element 0))
         (position->score    (make-array n-vocab :element-type 'single-float :initial-element 0.0)))
    (loop with cumsum = 0
          for word across vocabulary
          for score across scores
          for nth upfrom 0
          do (setf (aref position->word-pos nth) cumsum
                   (aref position->word-len nth) (length word)
                   (aref position->score nth) score
                   cumsum (+ cumsum (length word))))
    (make-dictionary :word-pool word-pool
                     :position->offset position->word-pos
                     :position->word-len position->word-len
                     :position->score position->score)))

;; (Simple-Tokenizer "Hello, World!" "HeloWrd!" 13 9)

(defaction SentencePiece (text vocabulary vocab_len_table words scores len n_vocab)
  "Implements SentencePipece
- Paper:
- Reference: https://github.com/karpathy/llama2.c/blob/master/run.c#L452

Vocabulary:
- vocabulary ID -> IDX to offset in words
- vocabulary ID -> word length
"
  (declare (type (:array :row (len) :char) text)
           (type (:array :row (n_vocab) :float32) vocabulary)
           (type (:pointer :float32) scores)
           (type :int64 m len)
           (optimize (debug 1)))
  (let ((best_score -1e10)
        (best_id -1)
        (best_index -1)
        (str_buffer (_%allocate-sized-array :char (* len 2)))
        (str_len 0)
        (tokens (map :int64 (lambda (c) (position c vocabulary)) text))
        (end_flag 0))
    (dotimes (i (length tokens))
      (when (= 0 end_flag)
        
        ))
    ))
|#
;; - [ ] SentencePieceが実装できる程度の機能があれば十分すぎる
;;(defaction Test (x i k)
;;  (declare (type (:array :row (i k) :float) x)
;;           (type :int32 i k))
;;  (setf (aref x 2 2) 2.0)
;;  (let ((a x))
;;    (setf (aref a 3 2) 1.0)
;;    a))

;; Segv しそ~...

;; What value do we want to return?
;; A single scalar value
;; 
;; fix the default int! :int and use *default-int*
#|
(defaction TestFunc (n)
  (declare (type :int64 n))
  (let ((m (* 10 n)))
    (if (> m 1)
        (let ((s (* m 10)))
          s)
        n)))

(defaction Test (x i k)
  (declare (type (:array :row (i k) :float) x)
           (type :int32 i k))
  (setf (aref x 2 2) 2.0)
  (let ((a x))
    (setf (aref a 3 2) 1.0)
    a))

(defaction Matmul (x y z m n k)
  (declare (type (:array :row (m n) :float) x)
           (type (:array :row (n k) :float) y)
           (type (:array :row (m k) :float) z)
           (type :int32 m n k))
  (dotimes (mm m)
    (dotimes (nn n)
      (dotimes (kk k)
        (setf (aref z mm kk) (+ (aref z mm kk) (* (aref x mm nn) (aref y nn kk))))))))

;; Defstructできるようにしたくなった。
;; SentencePieceはCatenで実装できそう

|#

;; - [ ] Allow to use under_score
;; - [x] does it works for higher rank array? (serf aref) (need tests)
;; - [x] Compile+Runできるようにして
;; - [x] Test-Suiteできるようにする
;; - [x] funcallする
;; = [x] Return Value
;; - [ ] Allow make-tensor inside the action.
;; - [ ] Implement, Break, Continue, Return w/o new ops
;; - [x] Let
;; - [x] Pointer, Array
;;  - [x] Sized Array
;;  - [x] Aref
;;  - [x] (setf aref)
;; - [x] String(an array of int4)
;; - [x] String Syntax (automatically converted into a list of int8)
;;   - [x] Array Creation in the code.
;;   - [x] Allow to return a pointer
;;   - [x] Allow to initialize a pointer. (float* x;) (due to _%setf)
;; - [x] dotimes
;; - [ ] Free pointer
;;   - [x] (NO) ~~ Or, having objects as a Common Lisp Object. Dont allocate pointer inside the compiled code.~~
;; - [ ] Autoinfer the bound of tensor (M N K is rebundant!)
;; - [ ] Return a value
;; - [ ] with-scop (Auto Scheduler is available!)
;; - [ ] return, return values;
;; - [ ] Implement MoE (That is, Module and Action interop)
;; - [ ] Compile into foreign language
;; - [ ] Provide a test
;; - [ ] Provide a full documentation!
;; - [ ] (declare (optimize (debug 3)))でコードを表示する
;; - [ ] May need new ops: :FREE :FREAD :FWRITE

;; =, Length are action
;; TODO: defaction: workflow configを一緒に提供する (dokode?)
;; - defactionで想定しているもの:
;;  - [ ] MoEのGating (なので，ModuleとのInteropを簡単にする)
;;  - [ ] Model Weight読み込みの実装 (ConfigからPathなどを読み込める必要がある)
;;  - [ ] Tokenizerの実装
;;  - [ ] Tensor Allocation, Dynamic Shapeの計算
;;   - [ ] make-tensor from action
;;  - [ ] Compiled AVMを呼び出す(例えばArgmax単体とか，このコンパイルの判定を自動でやりたい)
;; (defaction switch (condition action1 action2)
;;
;; Add Test:
;; - [ ] Sized :Allocate Test
;; - [ ] :TAKE Test ...
;; - 粒度の細かいテストが欲しい・・・
